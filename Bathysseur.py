# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Bathysseur
                                 A QGIS plugin
 Ce plugin permet d'interpoler la bathymétrie d'un fleuve ou d'une rivière entre deux profils bathymétriques.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-20
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Florent Bourhis (Cerema)
        email                : florent.bourhis@cerema.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

#import ogr, osr, os, sys
import csv
import pandas as pd
from qgis.PyQt.QtCore import QVariant

from PyQt5.QtCore import QFileInfo
from PyQt5.QtCore import *
from PyQt5.QtGui import *

import processing
from qgis.core import (
  QgsGeometry,
  QgsPoint,
  QgsPointXY,
  QgsWkbTypes,
  QgsProject,
  QgsFeatureRequest,
  QgsVectorLayer,
  QgsVectorFileWriter,
  QgsDistanceArea,
  QgsUnitTypes,
  QgsCoordinateTransform,
  QgsCoordinateReferenceSystem,
  QgsField,
  QgsFeature,
  QgsRasterLayer,
  QgsRaster
)

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Bathysseur_dialog import BathysseurDialog
from .Bathysseur_dialog import BathysseurDialogAideDiscretisation
import os.path


class Bathysseur:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Bathysseur_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Bathysseur')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Bathysseur', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Bathysseur/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Construction bathymétrie'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Bathysseur'),
                action)
            self.iface.removeToolBarIcon(action)
    
    def triDecroissant(self,liste):
        #On met dans l ordre decroissant les elements d une liste.
        listeDecroissante = []
        for element in liste:
            if listeDecroissante == []:
                listeDecroissante = [element]
            else:
                position = 0
                while element < listeDecroissante[position]:
                    position = position + 1
                    if position == len(listeDecroissante):
                        break
                listeDecroissante = listeDecroissante[:position] + [element] + listeDecroissante[position:]
        return listeDecroissante
    
    def droiteParallele(self,x1_coefDir,y1_coefDir,x2_coefDir,y2_coefDir):
        #Fonction permettant de determiner si deux segments de droite sont paralleles.
        #On calcule le produit scalaire d'un vecteur directeur d'un des segments par le vecteur directeur d'une droite orthogonale a l autre segment.
        #Si c est egal a zero, alors les droites son paralleles.
        parallele = False
        if x1_coefDir*(-y2_coefDir)+y1_coefDir*x2_coefDir == 0:
            parallele = True
        return parallele

    def xy_pointIntersection(self,x1,y1,x1_coefDir,y1_coefDir,x2,y2,x2_coefDir,y2_coefDir):
        #Fonction qui retourne les coordonnées du point d'intersection de deux droites.
        #Ces deux droites sont definies par un point et un coefficient directeur.
        #Initialisation des paramètres :
        x_pointIntersection = 0
        y_pointIntersection = 0
        parallele = self.droiteParallele(x1_coefDir,y1_coefDir,x2_coefDir,y2_coefDir)
        if not parallele:
            if x1_coefDir != 0 and x2_coefDir != 0:
                a = y1_coefDir/x1_coefDir
                b = y1-a*x1
                c = y2_coefDir/x2_coefDir
                d = y2-c*x2
                if a != c:
                    x_pointIntersection = (d-b)/(a-c)
                    y_pointIntersection = a*x_pointIntersection+b
            elif x1_coefDir == 0 and x2_coefDir != 0:
                x_pointIntersection = x1
                c = y2_coefDir/x2_coefDir
                d = y2-c*x2
                if c != 0:
                    y_pointIntersection = c*x_pointIntersection+d
                else:
                    y_pointIntersection = y2
            elif x1_coefDir != 0 and x2_coefDir == 0:
                x_pointIntersection = x2
                a = y1_coefDir/x1_coefDir
                b = y1-a*x1
                if a != 0:
                    y_pointIntersection = a*x_pointIntersection+b
                else:
                    y_pointIntersection = y1
        else:
            x_pointIntersection = 'inf'
            y_pointIntersection = 'inf'
        return [x_pointIntersection,y_pointIntersection]

    def descriptionBerges(self,coucheBerges):
        #Definbition d un dictionnaire dans lequel on va mettre tous les points qui decrivent les berges.
        descriptionBerge = {'Gauche':[],'Droite':[]}
        #On boucle sur les berges.
        berges = coucheBerges.getFeatures()
        for berge in berges:
            geometrieBerge = berge.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieBerge.wkbType())
            if geometrieBerge.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoBerge = geometrieBerge.asPolyline()
                else:
                    geoBerge = geometrieBerge.asMultiPolyline()
                #On boucle sur les points qui constituent la berge.
                for numPoint in range(len(geoBerge[0])):
                    point = geoBerge[0][numPoint]
                    x_point = point.x()
                    y_point = point.y()
                    descriptionBerge[berge[1]].append([x_point,y_point])
        return descriptionBerge

    def intersectionAvecBerge(self,desBerges,coteBerge,x,y,c_x,c_y):
        #On va rechercher tous les points d intersection possibles entre un profil donne et les berges.
        #Puis on choisira le point d intersection qui se situe le plus pres de l axe du cours d eau.
        distanceApprochee = 1000000
        listePointsIntersection = []
        for numPoint in range(len(desBerges[coteBerge])-1):
            pointA_x = desBerges[coteBerge][numPoint][0]
            pointA_y = desBerges[coteBerge][numPoint][1]
            pointB_x = desBerges[coteBerge][numPoint+1][0]
            pointB_y = desBerges[coteBerge][numPoint+1][1]
            x_coeffDirBerge = pointB_x - pointA_x
            y_coeffDirBerge = pointB_y - pointA_y
            pointIntersectionBerge = self.xy_pointIntersection(x,y,c_x,c_y,pointA_x,pointA_y,x_coeffDirBerge,y_coeffDirBerge)
            if pointIntersectionBerge != ['inf','inf']:
                if (pointA_x - pointIntersectionBerge[0])*(pointB_x - pointIntersectionBerge[0]) <= 0.001 and (pointA_y - pointIntersectionBerge[1])*(pointB_y - pointIntersectionBerge[1]) <= 0.001:
                    listePointsIntersection.append(pointIntersectionBerge)
                distanceApprocheePoint = max(0,(pointA_x - pointIntersectionBerge[0])*(pointB_x - pointIntersectionBerge[0])) + max(0,(pointA_y - pointIntersectionBerge[1])*(pointB_y - pointIntersectionBerge[1]))
                if distanceApprocheePoint < distanceApprochee:
                    distanceApprochee = distanceApprocheePoint
                    pointParDefaut = pointIntersectionBerge
        #Tous les points d intersection avec la berge ont ete trouves. On selectionne maintenant celui qui est le plus proche du point etudie.
        #On initialise le parametre distance avec le premier point d intersection trouve. On prend le carre de la distance (cela fait le calcul d une racine carree en moins a faire).
        if listePointsIntersection != []:
            distance = (x-listePointsIntersection[0][0])**2+(y-listePointsIntersection[0][1])**2
            pointIntersectionAvecBerge = listePointsIntersection[0]
            for pointIntersection in listePointsIntersection:
                distancePoint = (x-pointIntersection[0])**2+(y-pointIntersection[1])**2
                if distancePoint < distance:
                    distance = distancePoint
                    pointIntersectionAvecBerge = pointIntersection
        else:
            pointIntersectionAvecBerge = pointParDefaut
        return pointIntersectionAvecBerge

    def constructionDesProfils(self,listeProfilsInterpolation,descriptifAxeCoursDEauParcouru,abscisseProfilInterpolation,profilsEnAttente,desBerges,listeProfilBathyEtude,distanceEntreProfils):
        positionAxe = 0
        while abscisseProfilInterpolation >= descriptifAxeCoursDEauParcouru[positionAxe][2]:
            positionAxe = positionAxe + 1
        distancePointA = descriptifAxeCoursDEauParcouru[positionAxe-1][2]
        distancePointB = descriptifAxeCoursDEauParcouru[positionAxe][2]
        x_pointA = descriptifAxeCoursDEauParcouru[positionAxe-1][0]
        y_pointA = descriptifAxeCoursDEauParcouru[positionAxe-1][1]
        x_pointB = descriptifAxeCoursDEauParcouru[positionAxe][0]
        y_pointB = descriptifAxeCoursDEauParcouru[positionAxe][1]
        #On calcule tout d abord les coordonnees du point d intersection du profil avec l axe du cours d eau.
        x_IntersectionProfil = x_pointA + (x_pointB - x_pointA)*(abscisseProfilInterpolation - distancePointA)/(distancePointB-distancePointA)
        y_IntersectionProfil = y_pointA + (y_pointB - y_pointA)*(abscisseProfilInterpolation - distancePointA)/(distancePointB-distancePointA)
        #On calcule maintenant le coefficient directeur du segment.
        x_coefDir = -(y_pointB - y_pointA)
        y_coefDir = x_pointB - x_pointA
        #On recherche le profil bathymetrique qui se situe juste apres le profil ou interpoler qu on est en train de construire.
        numProfil = 0
        dansIndex = True
        while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation and dansIndex:
            numProfil = numProfil + 1
            if numProfil == len(listeProfilBathyEtude) - 1:
                if listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation:
                    dansIndex = False
            elif numProfil == len(listeProfilBathyEtude):
                break
        if not dansIndex:
            numProfil = numProfil + 1
        #On determine les coordonnees du point d intersection du profil ou interpoler et du profil bathymetrique qui se situe juste apres.
        encoreUnProfilBathymetrique = False
        coordonneesProfilVsBathy = [0,0]
        if numProfil < len(listeProfilBathyEtude):
            x_profilBathyEtude = listeProfilBathyEtude[numProfil][0]
            y_profilBathyEtude = listeProfilBathyEtude[numProfil][1]
            x_coefDirBathy = listeProfilBathyEtude[numProfil][2] - listeProfilBathyEtude[numProfil][0]
            y_coefDirBathy = listeProfilBathyEtude[numProfil][3] - listeProfilBathyEtude[numProfil][1]
            coordonneesProfilVsBathy = self.xy_pointIntersection(x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir,x_profilBathyEtude,y_profilBathyEtude,x_coefDirBathy,y_coefDirBathy)
            if coordonneesProfilVsBathy != ['inf','inf']:
                encoreUnProfilBathymetrique = True
        #On determine si le profil ou interpoler intersecte le profil bathymetrique a l interieur des berges.
        if encoreUnProfilBathymetrique and (coordonneesProfilVsBathy[0] - listeProfilBathyEtude[numProfil][0])*(coordonneesProfilVsBathy[0] - listeProfilBathyEtude[numProfil][2]) <= 0 and (coordonneesProfilVsBathy[1] - listeProfilBathyEtude[numProfil][1])*(coordonneesProfilVsBathy[1] - listeProfilBathyEtude[numProfil][3]) <= 0:
            #Le point d intersection se situe entre les berges.
            #On va determiner le point d intersection du dernier profil cree avec le profil bathymetrique.
            #Mais on va d'abord verifier qu'il y a bien au moins un profil cree.
            if  listeProfilsInterpolation != []:
                dernierProfil = listeProfilsInterpolation[len(listeProfilsInterpolation)-1]
                xG_dernierProfil = dernierProfil[0]
                yG_dernierProfil = dernierProfil[1]
                xD_dernierProfil = dernierProfil[2]
                yD_dernierProfil = dernierProfil[3]
                x_coefDirDernierProfil = xD_dernierProfil - xG_dernierProfil
                y_coefDirDernierProfil = yD_dernierProfil - yG_dernierProfil
                coordonneesPointPivot = self.xy_pointIntersection(xG_dernierProfil,yG_dernierProfil,x_coefDirDernierProfil,y_coefDirDernierProfil,x_profilBathyEtude,y_profilBathyEtude,x_coefDirBathy,y_coefDirBathy)
                #Si jamais le profil bathy et le dernier profil bathy sont paralleles, pas de point d intersection.
                #On en cree donc un de toute piece, de facon a ce que le profil a creer soit lui aussi parallele au profil bathy. 
                if coordonneesPointPivot == ['inf','inf']:
                    x_pointPivot = x_IntersectionProfil + x_coefDirDernierProfil
                    y_pointPivot = y_IntersectionProfil + y_coefDirDernierProfil
                    coordonneesPointPivot = [x_pointPivot,y_pointPivot]
                x_pointPivot = coordonneesPointPivot[0]
                y_pointPivot = coordonneesPointPivot[1]
                for profilEnAttente in profilsEnAttente:
                    x_coefDirProfilAttente = profilEnAttente[1] - x_pointPivot
                    y_coefDirProfilAttente = profilEnAttente[2] - y_pointPivot
                    pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',profilEnAttente[1],profilEnAttente[2],x_coefDirProfilAttente,y_coefDirProfilAttente)
                    pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',profilEnAttente[1],profilEnAttente[2],x_coefDirProfilAttente,y_coefDirProfilAttente)
                    #Le 0 final signifie que le nouveau profil n est pas un profil bathymetrique.
                    nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],profilEnAttente[0],0]
                    listeProfilsInterpolation.append(nouveauProfil)
                #Creation du profil auquel on etait arrive.
                x_coefDirProfilAvantBathy = x_IntersectionProfil - x_pointPivot
                y_coefDirProfilAvantBathy = y_IntersectionProfil - y_pointPivot
                pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_IntersectionProfil,y_IntersectionProfil,x_coefDirProfilAvantBathy,y_coefDirProfilAvantBathy)
                pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_IntersectionProfil,y_IntersectionProfil,x_coefDirProfilAvantBathy,y_coefDirProfilAvantBathy)
                nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],abscisseProfilInterpolation,0]
                listeProfilsInterpolation.append(nouveauProfil)
                while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation + distanceEntreProfils:
                    profilBathyAIntegrer = listeProfilBathyEtude[numProfil]
                    listeProfilsInterpolation.append(profilBathyAIntegrer)
                    numProfil = numProfil + 1
                    if numProfil > len(listeProfilBathyEtude) - 1:
                        break
                abscisseProfilInterpolation = abscisseProfilInterpolation + distanceEntreProfils
            else:
                #Dans le cas ou aucun profil ou interpoler n a encore ete cree et que le profil qu on cherche a creer intersecte le profil bathy suivant,
                #alors le profil a creer sera parallele au profil bathy suivant.
                x_coefDirProfilAvantBathy = pointIntersectionProfilBathyBergeGauche[0] - pointIntersectionProfilBathyBergeDroite[0]
                y_coefDirProfilAvantBathy = pointIntersectionProfilBathyBergeGauche[1] - pointIntersectionProfilBathyBergeDroite[1]
                pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',pointIntersectionProfilBathyBergeGauche[0],pointIntersectionProfilBathyBergeGauche[1],x_coefDirProfilAvantBathy,y_coefDirProfilAvantBathy)
                pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',pointIntersectionProfilBathyBergeGauche[0],pointIntersectionProfilBathyBergeGauche[1],x_coefDirProfilAvantBathy,y_coefDirProfilAvantBathy)
                nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],abscisseProfilInterpolation,0]
                listeProfilsInterpolation.append(nouveauProfil)
                while listeProfilBathyEtude[numProfil][4] > abscisseProfilInterpolation+distanceEntreProfils:
                    abscisseProfilInterpolation = abscisseProfilInterpolation+distanceEntreProfils
                    while abscisseProfilInterpolation >= descriptifAxeCoursDEauParcouru[positionAxe][2]:
                        positionAxe = positionAxe + 1
                    distancePointA = descriptifAxeCoursDEauParcouru[positionAxe-1][2]
                    x_pointA = descriptifAxeCoursDEauParcouru[positionAxe-1][0]
                    y_pointA = descriptifAxeCoursDEauParcouru[positionAxe-1][1]
                    x_pointB = descriptifAxeCoursDEauParcouru[positionAxe][0]
                    y_pointB = descriptifAxeCoursDEauParcouru[positionAxe][1]    
                    x_IntersectionProfil = x_pointA + (x_pointB - x_pointA)*(abscisseProfilInterpolation - distancePointA)
                    y_IntersectionProfil = y_pointA + (y_pointB - y_pointA)*(abscisseProfilInterpolation - distancePointA)
                    pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_IntersectionProfil,y_IntersectionProfil,x_coefDirProfilAvantBathy,y_coefDirProfilAvantBathy)
                    pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_IntersectionProfil,y_IntersectionProfil,x_coefDirProfilAvantBathy,y_coefDirProfilAvantBathy)
                    nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],abscisseProfilInterpolation,0]
                    listeProfilsInterpolation.append(nouveauProfil)
                while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation + distanceEntreProfils:
                    profilBathyAIntegrer = listeProfilBathyEtude[numProfil]
                    listeProfilsInterpolation.append(profilBathyAIntegrer)
                    numProfil = numProfil + 1
                    if numProfil > len(listeProfilBathyEtude) - 1:
                        break
                abscisseProfilInterpolation = abscisseProfilInterpolation + distanceEntreProfils
        else:
            #Le profil a creer n intercepte pas le profil bathymetrique suivant.
            #On se demande alors si le profil a creer intercepte le profil precedent a l interieur des berges.
            if listeProfilsInterpolation != []:
                dernierProfil = listeProfilsInterpolation[len(listeProfilsInterpolation)-1]
                x_bergeGauche = dernierProfil[0]
                y_bergeGauche = dernierProfil[1]
                x_bergeDroite = dernierProfil[2]
                y_bergeDroite = dernierProfil[3]
                x_coefDirDernierProfil = x_bergeGauche - x_bergeDroite
                y_coefDirDernierProfil = y_bergeGauche - y_bergeDroite
                coordonneesPointIntersection = self.xy_pointIntersection(x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir,x_bergeGauche,y_bergeGauche,x_coefDirDernierProfil,y_coefDirDernierProfil)
                if coordonneesPointIntersection != ['inf','inf']:
                    x_PI = coordonneesPointIntersection[0]
                    y_PI = coordonneesPointIntersection[1]
                    if (x_bergeGauche - x_PI)*(x_bergeDroite - x_PI) <= 0 and (y_bergeGauche - y_PI)*(y_bergeDroite - y_PI) <= 0:
                        profilsEnAttente.append([abscisseProfilInterpolation,x_IntersectionProfil,y_IntersectionProfil])
                        abscisseProfilInterpolation = abscisseProfilInterpolation + distanceEntreProfils
                        if not encoreUnProfilBathymetrique:
                            abscisseProfilInterpolation = self.constructionDesProfils(listeProfilsInterpolation,descriptifAxeCoursDEauParcouru,abscisseProfilInterpolation,profilsEnAttente,desBerges,listeProfilBathyEtude,distanceEntreProfils)
                        elif listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation:
                            dernierProfil = listeProfilsInterpolation[len(listeProfilsInterpolation)-1]
                            xG_dernierProfil = dernierProfil[0]
                            yG_dernierProfil = dernierProfil[1]
                            xD_dernierProfil = dernierProfil[2]
                            yD_dernierProfil = dernierProfil[3]
                            x_coefDirDernierProfil = xD_dernierProfil - xG_dernierProfil
                            y_coefDirDernierProfil = yD_dernierProfil - yG_dernierProfil
                            coordonneesPointPivot = self.xy_pointIntersection(xG_dernierProfil,yG_dernierProfil,x_coefDirDernierProfil,y_coefDirDernierProfil,x_profilBathyEtude,y_profilBathyEtude,x_coefDirBathy,y_coefDirBathy)
                            #Si jamais le profil bathy et le dernier profil ou interpoler sont paralleles, pas de point d intersection.
                            #On en cree donc un de toute piece, de facon a ce que le profil a creer soit lui aussi parallele au profil bathy. 
                            if coordonneesPointPivot == ['inf','inf']:
                                x_pointPivot = x_IntersectionProfil + x_coefDirDernierProfil
                                y_pointPivot = y_IntersectionProfil + y_coefDirDernierProfil
                                coordonneesPointPivot = [x_pointPivot,y_pointPivot]
                            x_pointPivot = coordonneesPointPivot[0]
                            y_pointPivot = coordonneesPointPivot[1]
                            for profilEnAttente in profilsEnAttente:
                                x_coefDirProfilAttente = profilEnAttente[1] - x_pointPivot
                                y_coefDirProfilAttente = profilEnAttente[2] - y_pointPivot
                                pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',profilEnAttente[1],profilEnAttente[2],x_coefDirProfilAttente,y_coefDirProfilAttente)
                                pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',profilEnAttente[1],profilEnAttente[2],x_coefDirProfilAttente,y_coefDirProfilAttente)
                                #Le 0 final signifie que le nouveau profil n est pas un profil bathymetrique.
                                nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],profilEnAttente[0],0]
                                listeProfilsInterpolation.append(nouveauProfil)
                            while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation:
                                profilBathyAIntegrer = listeProfilBathyEtude[numProfil]
                                listeProfilsInterpolation.append(profilBathyAIntegrer)
                                numProfil = numProfil + 1
                                if numProfil > len(listeProfilBathyEtude) - 1:
                                    break
                        else:
                            abscisseProfilInterpolation = self.constructionDesProfils(listeProfilsInterpolation,descriptifAxeCoursDEauParcouru,abscisseProfilInterpolation,profilsEnAttente,desBerges,listeProfilBathyEtude,distanceEntreProfils)
                    else:
                        for profilEnAttente in profilsEnAttente:
                            x_profilAttente = profilEnAttente[1]
                            y_profilAttente = profilEnAttente[2]
                            x_coeffDirProfilAttente = x_PI - profilEnAttente[1]
                            y_coeffDirProfilAttente = y_PI - profilEnAttente[2]
                            pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_profilAttente,y_profilAttente,x_coeffDirProfilAttente,y_coeffDirProfilAttente)
                            pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_profilAttente,y_profilAttente,x_coeffDirProfilAttente,y_coeffDirProfilAttente)
                            nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],profilEnAttente[0],0]
                            listeProfilsInterpolation.append(nouveauProfil)
                        #Il faut aussi ajouter le profil qu on etudiait.
                        pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir)
                        pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir)
                        nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],abscisseProfilInterpolation,0]
                        listeProfilsInterpolation.append(nouveauProfil)
                        abscisseProfilInterpolation = abscisseProfilInterpolation + distanceEntreProfils
                        if encoreUnProfilBathymetrique:
                            while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation:
                                profilBathyAIntegrer = listeProfilBathyEtude[numProfil]
                                listeProfilsInterpolation.append(profilBathyAIntegrer)
                                numProfil = numProfil + 1
                                if numProfil > len(listeProfilBathyEtude) - 1:
                                    break
                else:
                    for profilEnAttente in profilsEnAttente:
                        x_profilAttente = profilEnAttente[1]
                        y_profilAttente = profilEnAttente[2]
                        x_coeffDirProfilAttente = x_coefDir
                        y_coeffDirProfilAttente = y_coefDir
                        pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_profilAttente,y_profilAttente,x_coeffDirProfilAttente,y_coeffDirProfilAttente)
                        pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_profilAttente,y_profilAttente,x_coeffDirProfilAttente,y_coeffDirProfilAttente)
                        nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],profilEnAttente[0],0]
                        listeProfilsInterpolation.append(nouveauProfil)
                    #Il faut aussi ajouter le profil qu on etudiait.
                    pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir)
                    pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir)
                    nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],abscisseProfilInterpolation,0]
                    listeProfilsInterpolation.append(nouveauProfil)
                    abscisseProfilInterpolation = abscisseProfilInterpolation + distanceEntreProfils
                    if encoreUnProfilBathymetrique:
                        while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation:
                            profilBathyAIntegrer = listeProfilBathyEtude[numProfil]
                            listeProfilsInterpolation.append(profilBathyAIntegrer)
                            numProfil = numProfil + 1
                            if numProfil > len(listeProfilBathyEtude) - 1:
                                break
            else:
                pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir)
                pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_IntersectionProfil,y_IntersectionProfil,x_coefDir,y_coefDir)
                nouveauProfil = [pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],abscisseProfilInterpolation,0]
                listeProfilsInterpolation.append(nouveauProfil)
                while listeProfilBathyEtude[numProfil][4] < abscisseProfilInterpolation + distanceEntreProfils:
                    profilBathyAIntegrer = listeProfilBathyEtude[numProfil]
                    listeProfilsInterpolation.append(profilBathyAIntegrer)
                    numProfil = numProfil + 1
                    if numProfil > len(listeProfilBathyEtude) - 1:
                        break
                abscisseProfilInterpolation = abscisseProfilInterpolation + distanceEntreProfils
        return abscisseProfilInterpolation

    def genererProfilsInterpolation(self):
        #On initialise les donnees de la barre permettant le suivi de l avancement des calculs.
        self.dlg.progressionCalculProfilOuInterpoler.setValue(0)
        self.dlg.progressionCalculProfilOuInterpoler.setTextVisible(True)
        self.dlg.progressionCalculProfilOuInterpoler.setFormat('Calcul en cours... (0%)')
        #On recupere les donnees dont on a besoin : fichier des berges, de l'axe du cours d'eau,
        #des profils et des points bathymetriques, ainsi que la distance entre les profils intermediaires.
        distanceEntreProfils = int(self.dlg.distanceEntreProfilsIntermediaires.text())
        pathFichierBerges = self.dlg.fichierBerges.filePath()
        pathFichierAxe = self.dlg.fichierAxeCoursDEau.filePath()
        pathFichierProfilsLeveBathy = self.dlg.fichierProfilsLeveBathy.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des profils bathymetriques.
        recul = 1
        caractere = pathFichierProfilsLeveBathy[len(pathFichierProfilsLeveBathy)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierProfilsLeveBathy[len(pathFichierProfilsLeveBathy)-recul]
        pathDossierTravail = pathFichierProfilsLeveBathy[:-recul+1]
        #Ouverture des fichiers shape :
        coucheProfils = QgsVectorLayer(pathFichierProfilsLeveBathy,"ogr")
        coucheAxe = QgsVectorLayer(pathFichierAxe,"ogr")
        coucheBerges = QgsVectorLayer(pathFichierBerges,"ogr")
        #Creation de la couche vecteur dans laquelle les profils d interpolation seront generes :
        uri1 = 'linestring?crs=epsg:2154&field=id:integer'
        coucheProfilsInterpolation = QgsVectorLayer(uri1, 'profilsInterpolation', 'memory')
        #Creation de la couche vecteur dans laquelle seront generes les points d intersection des profils avec les berges :
        uri2 = 'point?crs=epsg:2154&field=id:integer'
        couchePointsIntersection = QgsVectorLayer(uri2, 'pointsIntersectionBerge', 'memory')
        #On determine la position des profils bathymetriques sur l axe du cours d eau.
        #On stocke dans un tableau des couples (profil,distance a l origine de l axe du cours d eau)
        axes = coucheAxe.getFeatures()
        profilsBathy = coucheProfils.getFeatures()
        desBerges = self.descriptionBerges(coucheBerges)
        #Au prealable, on stocke les informations sur les profils bathymetriques dans un tableau.
        #On suppose que les profils bathymetriques ne sont constitues que d un segment de droite.
        listeProfilBathy = []
        for profilBathy in profilsBathy:
            geometrieProfilBathy = profilBathy.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieProfilBathy.wkbType())
            if geometrieProfilBathy.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoProfilBathy = geometrieProfilBathy.asPolyline()
                else:
                    geoProfilBathy = geometrieProfilBathy.asMultiPolyline()
                pointA = geoProfilBathy[0][0]
                pointB = geoProfilBathy[0][1]
                x_pointA = pointA.x()
                y_pointA = pointA.y()
                x_pointB = pointB.x()
                y_pointB = pointB.y()
                x_coefDir = x_pointA - x_pointB
                y_coefDir = y_pointA - y_pointB
                pointIntersectionBergeGauche = self.intersectionAvecBerge(desBerges,'Gauche',x_pointA,y_pointA,x_coefDir,y_coefDir)
                pointIntersectionBergeDroite = self.intersectionAvecBerge(desBerges,'Droite',x_pointA,y_pointA,x_coefDir,y_coefDir)
                listeProfilBathy.append([pointIntersectionBergeGauche[0],pointIntersectionBergeGauche[1],pointIntersectionBergeDroite[0],pointIntersectionBergeDroite[1],profilBathy[0]])
        #On initialise un nouveau tableau.
        #On y stockera les caracteristiques des profils, en y ajoutant la distance a laquelle il se situe
        #le long de l axe du cours d eau.
        listeProfilBathyAvecDistance = []
        #On profite egalement de cette premiere boucle pour stocker les caracteristiques de l axe du cours d eau.
        #On initialise ce tableau.
        descriptifAxeCoursDEau = []
        #On cree un doublon de listeProfilBathy pour pouvoir supprimer des elements.
        listeProfilBathyPourBoucle = listeProfilBathy
        #Maintenant qu on a la liste des profils bathy, on peut balayer l axe du cours d eau.
        for axe in axes:
            geometrieAxe = axe.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieAxe.wkbType())
            if geometrieAxe.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoAxe = geometrieAxe.asPolyline()
                else:
                    geoAxe = geometrieAxe.asMultiPolyline()
                #On va parcourir l'axe du cours d'eau.
                #On va trouver les points d intersection des profils bathymetrique avec l axe du cours d eau.
                #On retiendra la distance (le long de l axe) a laquelle se situe l'intersection. On aura l'abscisse de l intersection.
                #On initialise la distance le long de l axe a zero.
                distanceLongAxe = 0
                for numPointLigne in range(len(geoAxe[0])-1):
                    pointA = geoAxe[0][numPointLigne]
                    pointB = geoAxe[0][numPointLigne+1]
                    x_pointA = pointA.x()
                    y_pointA = pointA.y()
                    x_pointB = pointB.x()
                    y_pointB = pointB.y()
                    #On enregistrera les positions des profils intersectes pour les enlever de la liste sur laquelle on boucle. Cela, pour gagner du temps et ne pas les compter 2 fois.
                    positionProfil = 0
                    listeProfilsAEnlever = []
                    descriptifAxeCoursDEau.append([x_pointA,y_pointA,distanceLongAxe])
                    for profil in listeProfilBathyPourBoucle:
                        x1 = profil[0]
                        y1 = profil[1]
                        x2 = profil[2]
                        y2 = profil[3]
                        x1_coefDir = x2 - x1
                        y1_coefDir = y2 - y1
                        x2_coefDir = x_pointB - x_pointA
                        y2_coefDir = y_pointB - y_pointA
                        coordonneesPointIntersection = self.xy_pointIntersection(x1,y1,x1_coefDir,y1_coefDir,x_pointA,y_pointA,x2_coefDir,y2_coefDir)
                        if coordonneesPointIntersection != ['inf','inf']:
                            if (coordonneesPointIntersection[0] - x_pointA)*(coordonneesPointIntersection[0] - x_pointB) <= 0:
                                if (coordonneesPointIntersection[1] - y_pointA)*(coordonneesPointIntersection[1] - y_pointB) <= 0:
                                    if (coordonneesPointIntersection[0] - x1)*(coordonneesPointIntersection[0] - x2) <= 0:
                                        if (coordonneesPointIntersection[1] - y1)*(coordonneesPointIntersection[1] - y2) <= 0:
                                            distanceProfil = distanceLongAxe + ((coordonneesPointIntersection[0]-x_pointA)**2+(coordonneesPointIntersection[1]-y_pointA)**2)**(1/2)
                                            profilAAjouter = profil[:-1]
                                            profilAAjouter.append(distanceProfil)
                                            profilAAjouter.append(profil[4])
                                            listeProfilBathyAvecDistance.append(profilAAjouter)
                                            listeProfilsAEnlever.append(positionProfil)
                        positionProfil = positionProfil + 1
                    listeProfilsAEnleverDecroissant = self.triDecroissant(listeProfilsAEnlever)
                    for position in listeProfilsAEnleverDecroissant:
                        del listeProfilBathyPourBoucle[position]
                    distanceLongAxe = distanceLongAxe + ((x_pointA-x_pointB)**2+(y_pointA-y_pointB)**2)**(1/2)
                #On stocke le dernier point de l axe du cours d eau dans le tableau decrivant ce dernier.
                descriptifAxeCoursDEau.append([x_pointB,y_pointB,distanceLongAxe])
        
        #On va maintenant creer un a un les profils intermediaires en y integrant les profils bathymetriques.
        #Dans la mesure du possible, les profils intermediaires seront perpendiculaires a l axe du cours d eau.
        #On initialise le tableau ou on va stocker les profils d interpolation.
        listeProfilsInterpolation = []
        listeProfilBathyEtude = listeProfilBathyAvecDistance
        abscisseProfilInterpolation = 0
        descriptifAxeCoursDEauParcouru = descriptifAxeCoursDEau
        #Initialisation des donnees permettant le suivi de l avancement des calculs.
        pourcentageAvancement = 1
        while abscisseProfilInterpolation < distanceLongAxe:
            profilsEnAttente = []
            abscisseProfilInterpolation = self.constructionDesProfils(listeProfilsInterpolation,descriptifAxeCoursDEauParcouru,abscisseProfilInterpolation,profilsEnAttente,desBerges,listeProfilBathyEtude,distanceEntreProfils)
            if abscisseProfilInterpolation/distanceLongAxe*100 > pourcentageAvancement:
                self.dlg.progressionCalculProfilOuInterpoler.setValue(pourcentageAvancement)
                self.dlg.progressionCalculProfilOuInterpoler.setFormat('Calcul en cours... ('+str(pourcentageAvancement)+'%)')
                pourcentageAvancement = pourcentageAvancement + 1
        #On a la liste des profils ou interpoler.
        #Cette liste est composee des elements suivants : [x_bergeGauche,y_bergeGauche,x_bergeDroite,y_bergeDroite,abscisseCurviligne,numeroProfil]
        #Le fichier vecteur produit comportera deux champs : un champ "abscisse" et un champ "numero de profil".
        listeChampsAAjouter = [QgsField("Abscisse",QVariant.Double),QgsField("Numero",QVariant.Int)]
        coucheProfilsInterpolation.dataProvider().addAttributes(listeChampsAAjouter)
        coucheProfilsInterpolation.updateFields()
        #Champs a ajouter au fichier vecteur dans lequel les points d intersection avec les berges seront enregistres.
        listeChampsAAjouter = [QgsField("Berge",QVariant.String),QgsField("Profil",QVariant.Int)]
        couchePointsIntersection.dataProvider().addAttributes(listeChampsAAjouter)
        couchePointsIntersection.updateFields()
        #On va ajouter les profils dans la coucheProfilsInterpolation.
        id = 1
        for profil in listeProfilsInterpolation:
            #Construction du fichier ou sont enregistres les profils ou interpoler.
            nouveauProfil = QgsFeature(coucheProfilsInterpolation.fields())
            listePoints = [QgsPointXY(profil[0],profil[1]),QgsPointXY(profil[2],profil[3])]
            nouvelleGeometrie = QgsGeometry.fromMultiPolylineXY([listePoints])
            nouveauProfil.setGeometry(nouvelleGeometrie)
            nouveauProfil.setAttribute(0,id)
            nouveauProfil.setAttribute(1,profil[4])
            nouveauProfil.setAttribute(2,profil[len(profil)-1])
            coucheProfilsInterpolation.dataProvider().addFeatures([nouveauProfil])
            #Construction du fichier ou sont enregistres les points d intersection avec les berges.
            nouveauPointGaucheIntersection =  QgsFeature(couchePointsIntersection.fields())
            nouveauPointDroitIntersection =  QgsFeature(couchePointsIntersection.fields())
            defPointGauche = QgsPointXY(profil[0],profil[1])
            defPointDroite = QgsPointXY(profil[2],profil[3])
            geometriePointGauche = QgsGeometry.fromPointXY(defPointGauche)
            geometriePointDroite = QgsGeometry.fromPointXY(defPointDroite)
            nouveauPointGaucheIntersection.setGeometry(geometriePointGauche)
            nouveauPointDroitIntersection.setGeometry(geometriePointDroite)
            nouveauPointGaucheIntersection.setAttribute(0,id*2-1)
            nouveauPointGaucheIntersection.setAttribute(1,'Gauche')
            nouveauPointGaucheIntersection.setAttribute(2,id)
            nouveauPointDroitIntersection.setAttribute(0,id*2)
            nouveauPointDroitIntersection.setAttribute(1,'Droite')
            nouveauPointDroitIntersection.setAttribute(2,id)
            couchePointsIntersection.dataProvider().addFeatures([nouveauPointGaucheIntersection])
            couchePointsIntersection.dataProvider().addFeatures([nouveauPointDroitIntersection])
            #On incremente id.
            id = id + 1
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolation.shp"):
            os.remove(pathDossierTravail+"ProfilsInterpolation.shp")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolation.dbf"):
            os.remove(pathDossierTravail+"ProfilsInterpolation.dbf")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolation.prj"):
            os.remove(pathDossierTravail+"ProfilsInterpolation.prj")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolation.cpg"):
            os.remove(pathDossierTravail+"ProfilsInterpolation.cpg")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolation.qmd"):
            os.remove(pathDossierTravail+"ProfilsInterpolation.qmd")
        if  os.path.exists(pathDossierTravail+"PointsIntersectionBerge.shp"):
            os.remove(pathDossierTravail+"PointsIntersectionBerge.shp")
        if  os.path.exists(pathDossierTravail+"PointsIntersectionBerge.dbf"):
            os.remove(pathDossierTravail+"PointsIntersectionBerge.dbf")
        if  os.path.exists(pathDossierTravail+"PointsIntersectionBerge.prj"):
            os.remove(pathDossierTravail+"PointsIntersectionBerge.prj")
        if  os.path.exists(pathDossierTravail+"PointsIntersectionBerge.cpg"):
            os.remove(pathDossierTravail+"PointsIntersectionBerge.cpg")
        if  os.path.exists(pathDossierTravail+"PointsIntersectionBerge.qmd"):
            os.remove(pathDossierTravail+"PointsIntersectionBerge.qmd")
        #Creation des fichiers shape finaux :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(coucheProfilsInterpolation,pathDossierTravail+"ProfilsInterpolation.shp",transform_context,save_options)
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(couchePointsIntersection,pathDossierTravail+"PointsIntersectionBerge.shp",transform_context,save_options)
        self.dlg.progressionCalculProfilOuInterpoler.setValue(100)
        self.dlg.progressionCalculProfilOuInterpoler.setFormat('Calcul terminé !')
    
    def determinerZBerges(self):
        self.dlg.labelInformationAvanceeCalcul.setText('Calcul en cours...')
        #On extrait l adresse d un des fichiers d entree.
        #Le but est d obtenir l adresse du dossier de travail.
        pathFichierPointsIntersection = self.dlg.fichierPointsIntersectionBerge.filePath()
        #On recupere le MNT.
        pathFichierMNT = self.dlg.fichierMNT.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des profils bathymetriques.
        recul = 1
        caractere = pathFichierPointsIntersection[len(pathFichierPointsIntersection)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierPointsIntersection[len(pathFichierPointsIntersection)-recul]
        pathDossierTravail = pathFichierPointsIntersection[:-recul+1]
        #On lance la routine Qgis appelee "Set Z From Raster"
        alg_params = {
            'BAND': 1,
            'INPUT': pathDossierTravail+"PointsIntersectionBerge.shp",
            'NODATA': -99,
            'OFFSET': 0,
            'RASTER': pathFichierMNT,
            'SCALE': 1,
            'OUTPUT': pathDossierTravail+"PointsIntersectionBergeAvecZ.shp"
        }
        processing.run('native:setzfromraster', alg_params)
        self.dlg.labelInformationAvanceeCalcul.setText('Calcul terminé !')
    
    def interpolationBathymetrieSurProfil(self):
        #On met a 0 la barre permettant de visualiser la progression des calculs.
        self.dlg.progressionCalculBathymetrieConnue.setValue(0)
        self.dlg.progressionCalculBathymetrieConnue.setTextVisible(True)
        self.dlg.progressionCalculBathymetrieConnue.setFormat('Calcul en cours... (0%)')
        #On recupere l adresse du fichier ou sont stockes les points bathymetriques.
        pathFichierPointsBathymetrie = self.dlg.fichierPointsBathymetriques.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des points bathymetriques, des profils bathymetriques, etc.
        recul = 1
        caractere = pathFichierPointsBathymetrie[len(pathFichierPointsBathymetrie)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierPointsBathymetrie[len(pathFichierPointsBathymetrie)-recul]
        pathDossierTravail = pathFichierPointsBathymetrie[:-recul+1]
        #Ouverture des fichiers shape :
        coucheProfils = QgsVectorLayer(pathDossierTravail+'ProfilsInterpolation.shp',"ogr")
        couchePointsBerges = QgsVectorLayer(pathDossierTravail+'PointsIntersectionBergeAvecZ.shp',"ogr")
        couchePointsBathymetriques = QgsVectorLayer(pathFichierPointsBathymetrie,"ogr")
        #On recupere la discretisation des profils definie par l utilisateur
        discretisation = int(self.dlg.discretisationProfil.text())
        #Avant toute chose, on recupere :
        #   1. les points ou la bathymetrie est connue.
        dictPointsBathy = {}
        pointsBathymetriques = couchePointsBathymetriques.getFeatures()
        for pointBathymetrique in pointsBathymetriques:
            geometriePointBathymetrique = pointBathymetrique.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometriePointBathymetrique.wkbType())
            #On recupere les coordonnees du point bathymetrique.
            if geometriePointBathymetrique.type() == QgsWkbTypes.PointGeometry:
                if geomSingleType:
                    geoPointBathymetrique = geometriePointBathymetrique.asPoint()
                    xPointBathy = geoPointBathymetrique.x()
                    yPointBathy = geoPointBathymetrique.y()
                else:
                    geoPointBathymetrique = geometriePointBathymetrique.asMultiPoint()
                    xPointBathy = geoPointBathymetrique[0].x()
                    yPointBathy = geoPointBathymetrique[0].y()
            if pointBathymetrique[0] in dictPointsBathy.keys():
                dictPointsBathy[pointBathymetrique[0]].append([xPointBathy,yPointBathy,pointBathymetrique[1]])
            else:
                dictPointsBathy.update({pointBathymetrique[0]:[[xPointBathy,yPointBathy,pointBathymetrique[1]]]})
        #   2. les points ou la bathymetrie est connue.
        pointsBerges = couchePointsBerges.getFeatures()
        dictPointsBergeGauche = {}
        dictPointsBergeDroite = {}
        for pointBerge in pointsBerges:
            geometriePointBerge = pointBerge.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometriePointBerge.wkbType())
            if geometriePointBerge.type() == QgsWkbTypes.PointGeometry:
                if geomSingleType:
                    geoPointBerge = geometriePointBerge.asPoint()
                else:
                    geoPointBerge = geometriePointBerge.asMultiPoint()
            xPointBerge = geoPointBerge.x()
            yPointBerge = geoPointBerge.y()
            zPointBerge = round(float(geometriePointBerge.asWkt().split(' ')[3][:-1]),2)
            if pointBerge[1] == 'Gauche':
                dictPointsBergeGauche.update({pointBerge[2]:[xPointBerge,yPointBerge,zPointBerge]})
            else:
                dictPointsBergeDroite.update({pointBerge[2]:[xPointBerge,yPointBerge,zPointBerge]})
        #Tout d abord, on va construire les profils ou la bathymetrie est connue.
        profils = coucheProfils.getFeatures()
        listeProfilsAvecBathymetrie = []
        nombreProfils = 0
        for profil in profils:
            nombreProfils = nombreProfils + 1
            if profil[2] != 0:
                #On recupere la description geometrique du profil.
                geometrieProfil = profil.geometry()
                geomSingleType = QgsWkbTypes.isSingleType(geometrieProfil.wkbType())
                if geometrieProfil.type() == QgsWkbTypes.LineGeometry:
                    if geomSingleType:
                        geoProfil = geometrieProfil.asPolyline()
                    else:
                        geoProfil = geometrieProfil.asMultiPolyline()
                #On recupere l altitude des points d intersection du profil avec les berges droite et gauche.
                xPointBergeGauche = dictPointsBergeGauche[profil[0]][0]
                yPointBergeGauche = dictPointsBergeGauche[profil[0]][1]
                zPointBergeGauche = dictPointsBergeGauche[profil[0]][2]
                xPointBergeDroite = dictPointsBergeDroite[profil[0]][0]
                yPointBergeDroite = dictPointsBergeDroite[profil[0]][1]
                zPointBergeDroite = dictPointsBergeDroite[profil[0]][2]
                #On recupere maintenant les points bathymetriques.
                #On les associe a un profil d interpolation.
                #Puis on les projette sur ce profil d interpolation.
                listePointsProjetesSurProfil = []
                listePointsProjetesSurProfil.append([0,zPointBergeGauche])
                for pointBathymetrique in dictPointsBathy[profil[2]]:
                    xPointBathy = pointBathymetrique[0]
                    yPointBathy = pointBathymetrique[1]
                    #On recupere les coordonnees du point bathymetrique.
                    #xPointBathy = geoPointBathymetrique.x()
                    #yPointBathy = geoPointBathymetrique.y()
                    #On projette ce point sur le profil bathymetrique.
                    xCoefDirProfil = xPointBergeGauche - xPointBergeDroite
                    yCoefDirProfil = yPointBergeGauche - yPointBergeDroite
                    coordonneesPointProjete = self.xy_pointIntersection(xPointBathy,yPointBathy,-yCoefDirProfil,xCoefDirProfil,xPointBergeGauche,yPointBergeGauche,xCoefDirProfil,yCoefDirProfil)
                    #On calcule l'abscisse (le long du profil d interpolation) de ce point d intersection.
                    #La berge gauche est prise comme origine du profil d interpolation.
                    abscissePointBathy = ((coordonneesPointProjete[0] - xPointBergeGauche)**2 + (coordonneesPointProjete[1] - yPointBergeGauche)**2)**(1/2)
                    zPointBathy = pointBathymetrique[2]
                    position = 0
                    while abscissePointBathy > listePointsProjetesSurProfil[position][0] :
                        position = position + 1
                        if position == len(listePointsProjetesSurProfil):
                            break
                    listePointsProjetesSurProfil.insert(position,[abscissePointBathy,zPointBathy])
                longueurProfil = ((xPointBergeDroite - xPointBergeGauche)**2 + (yPointBergeDroite - yPointBergeGauche)**2)**(1/2)
                #On ajoute la berge droite a la description du profil
                listePointsProjetesSurProfil.append([longueurProfil,zPointBergeDroite])
                #On construit maintenant les premiers profils bathymetriques.
                listePointsDescriptionProfil = []
                #On definit tout d abord la berge gauche.
                listePointsDescriptionProfil.append([xPointBergeGauche,yPointBergeGauche,zPointBergeGauche])
                #On definit ensuite les points intermediaires.
                pasDeDiscretisation = longueurProfil/(discretisation+1)
                positionPoint = 1
                numPointBathy = 0
                while positionPoint < discretisation+1:
                    while positionPoint*pasDeDiscretisation > listePointsProjetesSurProfil[numPointBathy][0]:
                        numPointBathy = numPointBathy + 1
                    abscissePointBathyPrecedent = listePointsProjetesSurProfil[numPointBathy-1][0]
                    zPointBathyPrecedent = listePointsProjetesSurProfil[numPointBathy-1][1]
                    abscissePointBathySuivant = listePointsProjetesSurProfil[numPointBathy][0]
                    zPointBathySuivant = listePointsProjetesSurProfil[numPointBathy][1]
                    zPointBathy = zPointBathyPrecedent + (zPointBathySuivant - zPointBathyPrecedent)*(positionPoint*pasDeDiscretisation - abscissePointBathyPrecedent)/(abscissePointBathySuivant - abscissePointBathyPrecedent)
                    xPointBathy = xPointBergeGauche + (xPointBergeDroite - xPointBergeGauche)*positionPoint*pasDeDiscretisation/longueurProfil
                    yPointBathy = yPointBergeGauche + (yPointBergeDroite - yPointBergeGauche)*positionPoint*pasDeDiscretisation/longueurProfil
                    listePointsDescriptionProfil.append([xPointBathy,yPointBathy,zPointBathy])
                    positionPoint = positionPoint + 1
                #On definit ensuite la berge droite.
                listePointsDescriptionProfil.append([xPointBergeDroite,yPointBergeDroite,zPointBergeDroite])
                #On ajoute le profil ainsi defini a la liste des profils.
                listeProfilsAvecBathymetrie.append([profil[1],profil[2],listePointsDescriptionProfil,longueurProfil])
        #Il s'agit maintenant de construire les profils intermediaires (ceux pour lesquels il n y a pas de bathymetrie associee)
        listeCompleteProfilsBathymetriques = listeProfilsAvecBathymetrie
        profils = coucheProfils.getFeatures()
        #On initialise les variables qui permettront de montrer l evolution des calculs.
        numeroProfil = 1
        pourcentage = 1
        for profil in profils:
            if profil[2] == 0:
                #On recupere l altitude des points d intersection du profil avec les berges droite et gauche.
                xPointBergeGauche = dictPointsBergeGauche[profil[0]][0]
                yPointBergeGauche = dictPointsBergeGauche[profil[0]][1]
                zPointBergeGauche = dictPointsBergeGauche[profil[0]][2]
                xPointBergeDroite = dictPointsBergeDroite[profil[0]][0]
                yPointBergeDroite = dictPointsBergeDroite[profil[0]][1]
                zPointBergeDroite = dictPointsBergeDroite[profil[0]][2]
                #On recupere les profils bathymetriques connus qui se situent directement a l aval et a l amont.
                positionProfilAval = 0
                while listeProfilsAvecBathymetrie[positionProfilAval][0] < profil[1] and positionProfilAval < len(listeProfilsAvecBathymetrie)-1:
                    positionProfilAval = positionProfilAval + 1
                #On initialise la description du profil:
                descriptionProfilIntermediaire = []
                #On ajoute, dans un premier temps, le point correspondant a la berge gauche.
                descriptionProfilIntermediaire.append([xPointBergeGauche,yPointBergeGauche,zPointBergeGauche])
                #On calcule la longueur du profil.
                longueurProfil = ((xPointBergeDroite - xPointBergeGauche)**2 + (yPointBergeDroite - yPointBergeGauche)**2)**(1/2)
                #On definit ensuite les points intermediaires.
                pasDeDiscretisation = longueurProfil/(discretisation+1)
                positionPoint = 1
                #Cas 1 : pas de profil amont.
                if positionProfilAval == 0:
                    profilAval = listeProfilsAvecBathymetrie[positionProfilAval][2]
                    zBergeGaucheAval = profilAval[0][2]
                    zBergeDroiteAval = profilAval[len(profilAval)-1][2]
                    while positionPoint < discretisation+1:
                        zPointIntermediaireProfilAval = profilAval[positionPoint][2]
                        zTheoriqueAval = zBergeGaucheAval + (zBergeDroiteAval - zBergeGaucheAval)/listeProfilsAvecBathymetrie[positionProfilAval][3]*(positionPoint*pasDeDiscretisation)
                        zTheoriqueProfil = zPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(zPointBergeDroite - zPointBergeGauche)
                        deltaZ = zTheoriqueProfil - zTheoriqueAval
                        zPointIntermediaireProfil = zPointIntermediaireProfilAval + deltaZ
                        xPointIntermediaireProfil = xPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(xPointBergeDroite - xPointBergeGauche)
                        yPointIntermediaireProfil = yPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(yPointBergeDroite - yPointBergeGauche)
                        descriptionProfilIntermediaire.append([xPointIntermediaireProfil,yPointIntermediaireProfil,zPointIntermediaireProfil])
                        positionPoint = positionPoint + 1
                #Cas 2 : pas de profil aval.
                elif profil[1] > listeProfilsAvecBathymetrie[positionProfilAval][0]:
                    profilAmont = listeProfilsAvecBathymetrie[positionProfilAval][2]
                    zBergeGaucheAmont = profilAmont[0][2]
                    zBergeDroiteAmont = profilAmont[len(profilAmont)-1][2]
                    while positionPoint < discretisation+1:
                        zPointIntermediaireProfilAmont = profilAmont[positionPoint][2]
                        zTheoriqueAmont = zBergeGaucheAmont + (zBergeDroiteAmont - zBergeGaucheAmont)/listeProfilsAvecBathymetrie[positionProfilAval][3]*(positionPoint*pasDeDiscretisation)
                        zTheoriqueProfil = zPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(zPointBergeDroite - zPointBergeGauche)
                        deltaZ = zTheoriqueProfil - zTheoriqueAmont
                        zPointIntermediaireProfil = zPointIntermediaireProfilAmont + deltaZ
                        xPointIntermediaireProfil = xPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(xPointBergeDroite - xPointBergeGauche)
                        yPointIntermediaireProfil = yPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(yPointBergeDroite - yPointBergeGauche)
                        descriptionProfilIntermediaire.append([xPointIntermediaireProfil,yPointIntermediaireProfil,zPointIntermediaireProfil])
                        positionPoint = positionPoint + 1
                #Cas 3 : un profil a l amont et un profil a l aval.
                else:
                    profilAval = listeProfilsAvecBathymetrie[positionProfilAval][2]
                    zBergeGaucheAval = profilAval[0][2]
                    zBergeDroiteAval = profilAval[len(profilAval)-1][2]
                    profilAmont = listeProfilsAvecBathymetrie[positionProfilAval-1][2]
                    zBergeGaucheAmont = profilAmont[0][2]
                    zBergeDroiteAmont = profilAmont[len(profilAval)-1][2]
                    #Determination des abscisses du profil etudie, du profil aval et du profil amont :
                    abscisseProfilAval = listeProfilsAvecBathymetrie[positionProfilAval][0]
                    abscisseProfilAmont = listeProfilsAvecBathymetrie[positionProfilAval-1][0]
                    abscisseProfil = profil[1]
                    #Definition de l'abscisse relative du profil :
                    abscisseRelativeProfil = (abscisseProfil - abscisseProfilAmont)/(abscisseProfilAval - abscisseProfilAmont)
                    #Calcul du delta z au niveau de la berge gauche :
                    zTheoriqueGauche = zBergeGaucheAmont + (zBergeGaucheAval - zBergeGaucheAmont)*abscisseRelativeProfil
                    deltaZGauche = zPointBergeGauche - zTheoriqueGauche
                    #Calcul du delta z au niveau de la berge gauche :
                    zTheoriqueDroite = zBergeDroiteAmont + (zBergeDroiteAval - zBergeDroiteAmont)*abscisseRelativeProfil
                    deltaZDroite = zPointBergeDroite - zTheoriqueDroite
                    while positionPoint < discretisation+1:
                        zPointIntermediaireProfilAval = profilAval[positionPoint][2]
                        zPointIntermediaireProfilAmont = profilAmont[positionPoint][2]
                        #zTheoriqueAval = zBergeGaucheAval + (zBergeDroiteAval - zBergeGaucheAval)/listeProfilsAvecBathymetrie[positionProfilAval][3]*(positionPoint*pasDeDiscretisation)
                        #zTheoriqueAmont = zBergeGaucheAmont + (zBergeDroiteAmont - zBergeGaucheAmont)/listeProfilsAvecBathymetrie[positionProfilAval-1][3]*(positionPoint*pasDeDiscretisation)
                        zBathyInterpoleProfil = zPointIntermediaireProfilAmont + (zPointIntermediaireProfilAval - zPointIntermediaireProfilAmont)*abscisseRelativeProfil
                        deltaZpourPoint = deltaZGauche + (deltaZDroite - deltaZGauche)*(positionPoint*pasDeDiscretisation)/longueurProfil
                        zPointIntermediaireProfil = zBathyInterpoleProfil + deltaZpourPoint
                        #zTheoriqueProfil = (zTheoriqueAval - zTheoriqueAmont)/(listeProfilsAvecBathymetrie[positionProfilAval][0]-listeProfilsAvecBathymetrie[positionProfilAval-1][0])*(profil[1]-listeProfilsAvecBathymetrie[positionProfilAval-1][0])
                        #zBergeInterpoleProfil = zPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(zPointBergeDroite - zPointBergeGauche)
                        #deltaZ = zBergeInterpoleProfil - zTheoriqueProfil
                        #zBathyInterpoleProfil = (zPointIntermediaireProfilAval - zPointIntermediaireProfilAmont)/(listeProfilsAvecBathymetrie[positionProfilAval][0]-listeProfilsAvecBathymetrie[positionProfilAval-1][0])*(profil[1]-listeProfilsAvecBathymetrie[positionProfilAval-1][0])
                        #zPointIntermediaireProfil = zBathyInterpoleProfil + deltaZ
                        xPointIntermediaireProfil = xPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(xPointBergeDroite - xPointBergeGauche)
                        yPointIntermediaireProfil = yPointBergeGauche + (positionPoint*pasDeDiscretisation)/longueurProfil*(yPointBergeDroite - yPointBergeGauche)
                        descriptionProfilIntermediaire.append([xPointIntermediaireProfil,yPointIntermediaireProfil,zPointIntermediaireProfil])
                        positionPoint = positionPoint + 1
                #On ajoute, enfin, le point correspondant a la berge droite.
                descriptionProfilIntermediaire.append([xPointBergeDroite,yPointBergeDroite,zPointBergeDroite])
                positionProfilIntermediaire = 0
                if profil[1] > listeCompleteProfilsBathymetriques[len(listeCompleteProfilsBathymetriques)-1][0]:
                    listeCompleteProfilsBathymetriques.insert(len(listeCompleteProfilsBathymetriques),[profil[1],profil[2],descriptionProfilIntermediaire,longueurProfil])
                else:
                    while profil[1] > listeCompleteProfilsBathymetriques[positionProfilIntermediaire][0]:
                        positionProfilIntermediaire = positionProfilIntermediaire + 1
                    listeCompleteProfilsBathymetriques.insert(positionProfilIntermediaire,[profil[1],profil[2],descriptionProfilIntermediaire,longueurProfil])
            if numeroProfil/nombreProfils*100 > pourcentage:
                self.dlg.progressionCalculBathymetrieConnue.setValue(pourcentage)
                self.dlg.progressionCalculBathymetrieConnue.setFormat('Calcul en cours... ('+str(pourcentage)+'%)')
                pourcentage = pourcentage + 1
            numeroProfil = numeroProfil + 1
        #Creation de la couche vecteur dans lequel les profils bathymetriques seront stockes.
        uri = 'linestring?crs=epsg:2154&field=id:integer'
        coucheProfilsBathymetriques = QgsVectorLayer(uri, 'profilsbathymetriques', 'memory')
        #On a la liste des profils bathymetriques.
        #Cette liste est composee des elements suivants : [abscisse,numero,[tous les points (x,y,z)],longueurDuProfil]
        #Le fichier vecteur produit comportera deux champs : un champ "abscisse" et un champ "numero de profil".
        listeChampsAAjouter = [QgsField("Abscisse",QVariant.Double),QgsField("Numero",QVariant.Int)]
        coucheProfilsBathymetriques.dataProvider().addAttributes(listeChampsAAjouter)
        coucheProfilsBathymetriques.updateFields()
        #On va ajouter les profils dans la coucheProfilsBathymetrique.
        id = 1
        for profilInterpole in listeCompleteProfilsBathymetriques:
            #Construction du fichier ou sont enregistres les profils ou interpoler.
            nouveauProfil = QgsFeature(coucheProfilsBathymetriques.fields())
            listePointsBathy = []
            for pointBathyFinal in profilInterpole[2]:
                listePointsBathy.append(QgsPoint(pointBathyFinal[0],pointBathyFinal[1],round(pointBathyFinal[2],2)))
            nouvelleGeometrie = QgsGeometry.fromPolyline(listePointsBathy)
            nouveauProfil.setGeometry(nouvelleGeometrie)
            nouveauProfil.setAttribute(0,id)
            nouveauProfil.setAttribute(1,profilInterpole[0])
            nouveauProfil.setAttribute(2,profilInterpole[1])
            coucheProfilsBathymetriques.dataProvider().addFeatures([nouveauProfil])
            id = id + 1
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrie.shp"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrie.shp")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrie.dbf"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrie.dbf")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrie.prj"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrie.prj")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrie.cpg"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrie.cpg")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrie.qmd"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrie.qmd")
        #Creation du fichier shape final :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        save_options.includeZ = True
        save_options.overrideGeometryType = QgsWkbTypes.LineStringZ
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(coucheProfilsBathymetriques,pathDossierTravail+"ProfilsInterpolationBathymetrie.shp",transform_context,save_options)
        self.dlg.progressionCalculBathymetrieConnue.setValue(100)
        self.dlg.progressionCalculBathymetrieConnue.setFormat('Calcul terminé !')
    
    def calculDiscretisationProfil(self):
        #On recupere l adresse du fichier ou sont stockes les points bathymetriques.
        pathFichierPointsBathymetrie = self.dlg.fichierPointsBathymetriques.filePath()
        #On recupere l adresse du modèle numerique de terrain.
        pathFichierMNT = self.dlg.fichierCaracteristiquesMNT.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des points bathymetriques, des profils bathymetriques, etc.
        recul = 1
        caractere = pathFichierPointsBathymetrie[len(pathFichierPointsBathymetrie)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierPointsBathymetrie[len(pathFichierPointsBathymetrie)-recul]
        pathDossierTravail = pathFichierPointsBathymetrie[:-recul+1]
        #On ouvre le fichier ou sont stockes les profils ou interpoler.
        coucheProfils = QgsVectorLayer(pathDossierTravail+'ProfilsInterpolation.shp',"ogr")
        #On boucle sur les profils ou interpoler :
        # -> On calcule les longueurs des profils.
        # -> On calcule la longueur moyenne des profils.
        profils = coucheProfils.getFeatures()
        sommeLongueurs = 0
        nbProfils = 0
        for profil in profils:
            geometrie = profil.geometry()
            longueur = geometrie.length()
            sommeLongueurs = sommeLongueurs + longueur
            nbProfils = nbProfils + 1
        longueurMoyenneProfils = sommeLongueurs/nbProfils
        #On recupere la taille des mailles du MNT.
        mnt = QgsRasterLayer(pathFichierMNT,"ogr")
        taillePixel = mnt.rasterUnitsPerPixelX()
        #On va recommander une discretisation des profils a l utilisateur.
        #On calcule cette discretisation.
        discretisation = int(longueurMoyenneProfils/taillePixel)
        #On affiche cette valeur recommandee pour la discretisation dans la QLineEdit du plug-in.
        self.dlg.discretisationProfil.clear()
        self.dlg.discretisationProfil.setText(str(discretisation))
    
    def constructionRasterBathymetrie(self):
        #On recupere l adresse du fichier ou sont stockes les points bathymetriques.
        pathFichierPointsBathymetrie = self.dlg.fichierPointsBathymetriques.filePath()
        #On recupere l adresse du modèle numerique de terrain.
        pathFichierMNT = self.dlg.fichierCaracteristiquesMNT.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des points bathymetriques, des profils bathymetriques, etc.
        recul = 1
        caractere = pathFichierPointsBathymetrie[len(pathFichierPointsBathymetrie)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierPointsBathymetrie[len(pathFichierPointsBathymetrie)-recul]
        pathDossierTravail = pathFichierPointsBathymetrie[:-recul+1]
        #On construit le chemin du fichier ou sont stockes les profils bathymetriques.
        pathFichierProfilsBathymetriques = pathDossierTravail+'ProfilsInterpolationBathymetrie.shp'
        #On recupere l extension du fichier ou sont stockes les profils bathymetriques.
        coucheProfils = QgsVectorLayer(pathDossierTravail+'ProfilsInterpolation.shp',"ogr")
        extensionProfils = coucheProfils.extent()
        #On recupere les abscisses minimales et maximales de l extension (des profils bathy).
        #On recupere egalement les ordonnees minimales et maximales de l extension (des profils bathy).
        xMin = extensionProfils.xMinimum()
        xMax = extensionProfils.xMaximum()
        yMin = extensionProfils.yMinimum()
        yMax = extensionProfils.yMaximum()
        #On recupere la taille des mailles et l'extension du MNT.
        mnt = QgsRasterLayer(pathFichierMNT,"ogr")
        taillePixel = mnt.rasterUnitsPerPixelX()
        extensionMNT = mnt.extent()
        #On recupere les abscisses minimales et maximales de l extension (du MNT).
        #On recupere egalement les ordonnees minimales et maximales de l extension (du MNT).
        xMinMNT = extensionMNT.xMinimum()
        xMaxMNT = extensionMNT.xMaximum()
        yMinMNT = extensionMNT.yMinimum()
        yMaxMNT = extensionMNT.yMaximum()
        #On determine les coordonnees de l extension du raster bathymetrique a construire.
        xMinBathy = xMinMNT + int((xMin - xMinMNT)/taillePixel)*taillePixel
        yMinBathy = yMinMNT + int((yMin - yMinMNT)/taillePixel)*taillePixel
        xMaxBathy = xMaxMNT - int((xMaxMNT - xMax)/taillePixel)*taillePixel
        yMaxBathy = yMaxMNT - int((yMaxMNT - yMax)/taillePixel)*taillePixel
        #On definit l extension du raster a generer.
        extensionBathy = str(xMinBathy)+','+str(xMaxBathy)+','+str(yMinBathy)+','+str(yMaxBathy)+' '+'['+coucheProfils.crs().authid()+']'
        #On definit l adresse du fichier de sortie.
        fichierSortie = pathDossierTravail+'Bathymetrie.tif'
        #On lance l'outil Qgis TIN Interpolation.
        parametres = {'INTERPOLATION_DATA':pathFichierProfilsBathymetriques+'::~::1::~::-1::~::1',
        'METHOD':0,
        'EXTENT':extensionBathy,
        'PIXEL_SIZE':taillePixel,
        'OUTPUT':fichierSortie}
        processing.run("qgis:tininterpolation", parametres)
        #Le raster decrivant la bathymetrie a ete produit.
        #Il reste desormais a decouper ce raster pour ne conserver que les pixels situes
        #entre les berges du cours d eau.
        #Pour ce faire, on utilise la fonction "clip raster by mask layer" de Qgis.
        #On definit d'abord le nom du fichier de sortie.
        fichierSortieMasque = pathDossierTravail+'BathymetrieMasquee.tif'
        #On definit l adresse du fichier shape dont lequel est stocke le polygone des berges.
        fichierPolygoneBerges = pathDossierTravail+'PolygoneBerges.shp'
        #On lance la fonction "clip raster by mask layer" de Qgis.
        parametres = {'INPUT':fichierSortie,
        'MASK':fichierPolygoneBerges,
        'SOURCE_CRS':QgsCoordinateReferenceSystem(coucheProfils.crs().authid()),
        'TARGET_CRS':QgsCoordinateReferenceSystem(coucheProfils.crs().authid()),
        'TARGET_EXTENT':None,
        'NODATA':None,
        'ALPHA_BAND':False,
        'CROP_TO_CUTLINE':True,
        'KEEP_RESOLUTION':False,
        'SET_RESOLUTION':False,
        'X_RESOLUTION':None,
        'Y_RESOLUTION':None,
        'MULTITHREADING':False,
        'OPTIONS':'',
        'DATA_TYPE':0,
        'EXTRA':'',
        'OUTPUT':fichierSortieMasque}
        processing.run("gdal:cliprasterbymasklayer", parametres)

    def bathymetrieElliptique(self):
        #On initialise les donnees de la barre donnant la progression du calcul.
        self.dlg.progressionCalculBathymetrieVirtuelle.setValue(0)
        self.dlg.progressionCalculBathymetrieVirtuelle.setTextVisible(True)
        self.dlg.progressionCalculBathymetrieVirtuelle.setFormat('Calcul en cours... (0%)')
        #On recupere le fichier ou sont definis les profils a interpoler.
        pathFichierProfilsOuInterpoler = self.dlg.fichierProfilsOuInterpoler.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des points bathymetriques, des profils bathymetriques, etc.
        recul = 1
        caractere = pathFichierProfilsOuInterpoler[len(pathFichierProfilsOuInterpoler)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierProfilsOuInterpoler[len(pathFichierProfilsOuInterpoler)-recul]
        pathDossierTravail = pathFichierProfilsOuInterpoler[:-recul+1]
        #Ouverture des fichiers shape :
        coucheProfils = QgsVectorLayer(pathDossierTravail+'ProfilsInterpolation.shp',"ogr")
        couchePointsBerges = QgsVectorLayer(pathDossierTravail+'PointsIntersectionBergeAvecZ.shp',"ogr")
        #On recupere la hauteur de la bathymetrie definie par l utilisateur.
        hauteurBathymetrie = float(self.dlg.profondeur.text())
        #On recupere la discretisation du demi-profil.
        discretisationDemiProfil = int(self.dlg.discretisationDemiProfil.text())
        #On initialise la liste des profils.
        listeProfilsBathymetrieVirtuelle = []
        #On compte le nombre de profils.
        nombreProfils = 0
        profils = coucheProfils.getFeatures()
        for profil in profils:
            nombreProfils = nombreProfils + 1
        #On initialise la variable permettant de suivre l'avancement des calculs.
        pourcentage = 1
        #On boucle sur chaque profil pour construire leurs bathymetries.
        profils = coucheProfils.getFeatures()
        profilsConstruits = 0
        for profil in profils:
            #On recherche d'abord l'altitude des berges de ce profil.
            pointsBerges = couchePointsBerges.getFeatures()
            for pointBerge in pointsBerges:
                if pointBerge[2] == profil[0]:
                    geometriePointBerge = pointBerge.geometry()
                    geomSingleType = QgsWkbTypes.isSingleType(geometriePointBerge.wkbType())
                    if geometriePointBerge.type() == QgsWkbTypes.PointGeometry:
                        if geomSingleType:
                            geoPointBerge = geometriePointBerge.asPoint()
                        else:
                            geoPointBerge = geometriePointBerge.asMultiPoint()
                    if pointBerge[1] == 'Gauche':
                        xPointBergeGauche = geoPointBerge.x()
                        yPointBergeGauche = geoPointBerge.y()
                        zPointBergeGauche = round(float(geometriePointBerge.asWkt().split(' ')[3][:-1]),2)
                    else:
                        xPointBergeDroite = geoPointBerge.x()
                        yPointBergeDroite = geoPointBerge.y()
                        zPointBergeDroite = round(float(geometriePointBerge.asWkt().split(' ')[3][:-1]),2)
            #On determine l'altitude de la berge la plus basse.
            zBergeMinimale = min(zPointBergeGauche,zPointBergeDroite)
            #On en deduit l'altitude du point bas de la bathymetrie.
            profondeurMinimale = zBergeMinimale - hauteurBathymetrie
            #On calcule maintenant la longueur du profil.
            longueurProfil = ((xPointBergeGauche - xPointBergeDroite)**2 + (yPointBergeGauche - yPointBergeDroite)**2)**(1/2)
            #On definit le pas de discretisation.
            pasDiscretisation = (longueurProfil/2)/discretisationDemiProfil
            #On initialise le tableau dans lequel on va stocker les points definissant le profil.
            descriptionProfil = []
            descriptionProfil.append([xPointBergeGauche,yPointBergeGauche,zPointBergeGauche]) 
            #On construit le premier demi-profil de la bathymetrie.
            position = 1
            while position*pasDiscretisation < longueurProfil/2 :
                #On definit la longueur du demi (petit ou grand) axe.
                a = longueurProfil/2
                #On definit la longueur de l'autre demi axe.
                b = zPointBergeGauche - profondeurMinimale
                #On definit x.
                x = longueurProfil/2 - position*pasDiscretisation
                #On calcule l altitude z du point bathymetrique d'abscisse position*pasDiscretisation.
                zPoint = zPointBergeGauche - ((b**2)*(1 - (x**2)/(a**2)))**(1/2)
                #On calcule les coordonnees x et y du point.
                xPoint = xPointBergeGauche + position*pasDiscretisation/longueurProfil*(xPointBergeDroite - xPointBergeGauche)
                yPoint = yPointBergeGauche + position*pasDiscretisation/longueurProfil*(yPointBergeDroite - yPointBergeGauche)
                #On ajoute ce point (x,y,z) a la liste des points definissant le profil.
                descriptionProfil.append([xPoint,yPoint,zPoint])
                position = position + 1
            #On ajoute le point central du profil bathymetrique a la liste des points le definissant.
            xPoint = xPointBergeGauche + (xPointBergeDroite - xPointBergeGauche)/2
            yPoint = yPointBergeGauche + (yPointBergeDroite - yPointBergeGauche)/2
            zPoint = profondeurMinimale
            descriptionProfil.append([xPoint,yPoint,zPoint])
            #On construit le deuxieme demi-profil de la bathymetrie.
            position = 1
            while position*pasDiscretisation < longueurProfil/2 :
                #On definit la longueur du demi (petit ou grand) axe.
                a = longueurProfil/2
                #On definit la longueur de l'autre demi axe.
                b = zPointBergeDroite - profondeurMinimale
                #On definit x.
                x = position*pasDiscretisation
                #On calcule l altitude z du point bathymetrique d'abscisse position*pasDiscretisation.
                zPoint = zPointBergeDroite - ((b**2)*(1 - (x**2)/(a**2)))**(1/2)
                #On calcule les coordonnees x et y du point.
                xPoint = xPointBergeGauche + (position*pasDiscretisation + longueurProfil/2)/longueurProfil*(xPointBergeDroite - xPointBergeGauche)
                yPoint = yPointBergeGauche + (position*pasDiscretisation + longueurProfil/2)/longueurProfil*(yPointBergeDroite - yPointBergeGauche)
                #On ajoute ce point (x,y,z) a la liste des points definissant le profil.
                descriptionProfil.append([xPoint,yPoint,zPoint])
                position = position + 1
            #On ajoute le point de la berge droite a la description du profil.
            descriptionProfil.append([xPointBergeDroite,yPointBergeDroite,zPointBergeDroite])
            listeProfilsBathymetrieVirtuelle.append([profil[0],profil[1],profil[2],descriptionProfil])
            profilsConstruits = profilsConstruits + 1
            if profilsConstruits/nombreProfils*100 > pourcentage:
                self.dlg.progressionCalculBathymetrieVirtuelle.setValue(pourcentage)
                self.dlg.progressionCalculBathymetrieVirtuelle.setFormat('Calcul en cours... ('+str(pourcentage)+'%)')
                pourcentage = pourcentage + 1
        #Creation de la couche vecteur dans lequel les profils bathymetriques seront stockes.
        uri = 'linestring?crs=epsg:2154&field=id:integer'
        coucheProfilsBathymetrieVirtuelle = QgsVectorLayer(uri, 'profilsbathymetrieVirtuelle', 'memory')
        #On a la liste des profils bathymetriques.
        #Cette liste est composee des elements suivants : [id,abscisse,numero,[tous les points (x,y,z)]]
        #Le fichier vecteur produit comportera deux champs : un champ "abscisse" et un champ "numero de profil".
        listeChampsAAjouter = [QgsField("Abscisse",QVariant.Double),QgsField("Numero",QVariant.Int)]
        coucheProfilsBathymetrieVirtuelle.dataProvider().addAttributes(listeChampsAAjouter)
        coucheProfilsBathymetrieVirtuelle.updateFields()
        #On va ajouter les profils dans la coucheProfilsBathymetrique.
        id = 1
        for profilVirtuel in listeProfilsBathymetrieVirtuelle:
            #Construction du fichier ou sont enregistres les profils ou interpoler.
            nouveauProfil = QgsFeature(coucheProfilsBathymetrieVirtuelle.fields())
            listePointsBathy = []
            for pointBathyFinal in profilVirtuel[3]:
                listePointsBathy.append(QgsPoint(pointBathyFinal[0],pointBathyFinal[1],round(pointBathyFinal[2],2)))
            nouvelleGeometrie = QgsGeometry.fromPolyline(listePointsBathy)
            nouveauProfil.setGeometry(nouvelleGeometrie)
            nouveauProfil.setAttribute(0,id)
            nouveauProfil.setAttribute(1,profilVirtuel[1])
            nouveauProfil.setAttribute(2,profilVirtuel[2])
            coucheProfilsBathymetrieVirtuelle.dataProvider().addFeatures([nouveauProfil])
            id = id + 1
        #On supprimer les fichiers a creer s'ils existent deja.
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.shp"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.shp")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.dbf"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.dbf")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.prj"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.prj")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.cpg"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.cpg")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.qmd"):
            os.remove(pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.qmd")
        #Creation du fichier shape final :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        save_options.includeZ = True
        save_options.overrideGeometryType = QgsWkbTypes.LineStringZ
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(coucheProfilsBathymetrieVirtuelle,pathDossierTravail+"ProfilsInterpolationBathymetrieVirtuelle.shp",transform_context,save_options)
        self.dlg.progressionCalculBathymetrieVirtuelle.setValue(100)
        self.dlg.progressionCalculBathymetrieVirtuelle.setFormat('Calcul terminé !')

    def genererLigneEau(self):
        #On initialise les donnees de la barre donnant la progression du calcul.
        self.dlg.progressionCalculLigneEauInitiale.setValue(0)
        self.dlg.progressionCalculLigneEauInitiale.setTextVisible(True)
        self.dlg.progressionCalculLigneEauInitiale.setFormat('Calcul en cours... (0%)')
        #On recupere le fichier ou sont definis les profils bathymetriques.
        pathFichierProfilsBathy = self.dlg.fichierProfilsBathymetriques.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des points bathymetriques, des profils bathymetriques, etc.
        recul = 1
        caractere = pathFichierProfilsBathy[len(pathFichierProfilsBathy)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierProfilsBathy[len(pathFichierProfilsBathy)-recul]
        pathDossierTravail = pathFichierProfilsBathy[:-recul+1]
        #Ouverture du fichier shape :
        coucheProfilsBathy = QgsVectorLayer(pathFichierProfilsBathy,"ogr")
        #On recupere le taux de remplissage du profil bathymetrique (meme si c'est un abus de langage que de parler d un taux de remplissage).
        tauxDebitMaximal = float(self.dlg.pourcentageDebit.text())
        coefficientStrickler = float(self.dlg.coefficientStrickler.text())
        #On boucle sur les profils.
        profils = coucheProfilsBathy.getFeatures()
        listeProfils = []
        self.dlg.progressionCalculLigneEauInitiale.setValue(5)
        self.dlg.progressionCalculLigneEauInitiale.setFormat('Calcul en cours : données récupérées... (5%)')
        for profil in profils:
            geometrieProfil = profil.geometry()
            #On va recuperer les coordonnees des points constituant le profil dans le tableau suivant (qu on initialise).
            listePointsProfil = []
            minZInitialise = False
            for coordonnees in geometrieProfil.asWkt()[19:-2].split(', '):
                coordonneesXYZ = coordonnees.split(' ')
                x = float(coordonneesXYZ[0])
                y = float(coordonneesXYZ[1])
                z = round(float(coordonneesXYZ[2]),2)
                listePointsProfil.append([x,y,z])
                if minZInitialise:
                    if z < minZ:
                        minZ = z
                else:
                    minZ = z
                    minZInitialise = True
            #On recupere les altitude des berges.
            zBergeGauche = listePointsProfil[0][2]
            zBergeDroite = listePointsProfil[len(listePointsProfil)-1][2]
            #On determine quelle est la berge la plus basse.
            if zBergeGauche > zBergeDroite:
                minZBerge = zBergeDroite
            else:
                minZBerge = zBergeGauche
            listeProfils.append([profil[1],minZ,minZBerge,listePointsProfil])
        #On renseigne l operateur sur l avancee des travaux.
        self.dlg.progressionCalculLigneEauInitiale.setValue(33)
        self.dlg.progressionCalculLigneEauInitiale.setFormat('Calcul en cours : z minimaux trouvés pour chaque profil... (33%)')
        #On determine le debit maximal pouvant circuler dans le cours d'eau (debit maximal sans debordement).
        numeroProfil = 0
        definitionDebitMaximal = False
        listeProfilsAvecPente = []
        for profil in listeProfils:
            #Pour chaque profil, on va determiner le debit maximal pour y circuler.
            #Pour ce faire, on va calculer la section mouillee et le perimetre mouille.
            #On considere que tous les points situes en-dessous de la berge la plus basse du profil sont mouilles.
            listePointsMouilles = []
            listePointsNonMouilles = []
            dernierPointMouille = False
            #On initialise le perimetre mouille et la section mouillee.
            perimetreMouille = 0
            sectionMouillee = 0
            for point in profil[3]:
                if point[2] < profil[2] or point[2] == profil[2]:
                    if listePointsMouilles != []:
                        #Des points mouilles ont deja ete recenses.
                        #On regarde si le dernier point etudie etait un point mouille.
                        #Si c est le cas, on calcule la portion de perimetre mouille et de section mouillee supplementaire.
                        if dernierPointMouille:
                            pointMouillePrecedent = listePointsMouilles[len(listePointsMouilles)-1]
                            xPrecedent = pointMouillePrecedent[0]
                            yPrecedent = pointMouillePrecedent[1]
                            zPrecedent = pointMouillePrecedent[2]
                            xPresent = point[0]
                            yPresent = point[1]
                            zPresent = point[2]
                            zMoyen = (zPresent + zPrecedent)/2
                            hauteurEauMoyenne = profil[2] - zMoyen
                            deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                            deltaCarreZ = (zPresent - zPrecedent)**2
                            deltaPerimetre = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                            deltaSection = ((deltaCarreAbscisse)**(1/2))*hauteurEauMoyenne
                            #On incremente le perimetre mouille et la section mouillee.
                            perimetreMouille = perimetreMouille + deltaPerimetre
                            sectionMouillee = sectionMouillee + deltaSection
                        elif listePointsNonMouilles != []:
                            pointNonMouillePrecedent = listePointsNonMouilles[len(listePointsMouilles)-1]
                            xPrecedent = pointNonMouillePrecedent[0]
                            yPrecedent = pointNonMouillePrecedent[1]
                            zPrecedent = pointNonMouillePrecedent[2]
                            xPresent = point[0]
                            yPresent = point[1]
                            zPresent = point[2]
                            hauteurEau = profil[2] - zPresent
                            deltaZ = abs(zPrecedent - zPresent)
                            deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                            deltaCarreZ = (zPresent - zPrecedent)**2
                            distanceEntrePoints = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                            deltaPerimetre = hauteurEau/deltaZ*distanceEntrePoints
                            deltaAbscisse = hauteurEau/deltaZ*(deltaCarreAbscisse**(1/2))
                            deltaSection = hauteurEau*deltaAbscisse/2
                            #On incremente le perimetre mouille et la section mouillee.
                            perimetreMouille = perimetreMouille + deltaPerimetre
                            sectionMouillee = sectionMouillee + deltaSection
                    else:
                        if listePointsNonMouilles != []:
                            pointNonMouillePrecedent = listePointsNonMouilles[len(listePointsMouilles)-1]
                            xPrecedent = pointNonMouillePrecedent[0]
                            yPrecedent = pointNonMouillePrecedent[1]
                            zPrecedent = pointNonMouillePrecedent[2]
                            xPresent = point[0]
                            yPresent = point[1]
                            zPresent = point[2]
                            hauteurEau = profil[2] - zPresent
                            deltaZ = abs(zPrecedent - zPresent)
                            deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                            deltaCarreZ = (zPresent - zPrecedent)**2
                            distanceEntrePoints = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                            deltaPerimetre = hauteurEau/deltaZ*distanceEntrePoints
                            deltaAbscisse = hauteurEau/deltaZ*(deltaCarreAbscisse**(1/2))
                            deltaSection = hauteurEau*deltaAbscisse/2
                            #On incremente le perimetre mouille et la section mouillee.
                            perimetreMouille = perimetreMouille + deltaPerimetre
                            sectionMouillee = sectionMouillee + deltaSection
                    listePointsMouilles.append(point)
                    dernierPointMouille = True
                else:
                    if dernierPointMouille:
                        pointMouillePrecedent = listePointsMouilles[len(listePointsMouilles)-1]
                        xPrecedent = pointMouillePrecedent[0]
                        yPrecedent = pointMouillePrecedent[1]
                        zPrecedent = pointMouillePrecedent[2]
                        xPresent = point[0]
                        yPresent = point[1]
                        zPresent = point[2]
                        hauteurEau = profil[2] - zPrecedent
                        deltaZ = abs(zPrecedent - zPresent)
                        deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                        deltaCarreZ = (zPresent - zPrecedent)**2
                        distanceEntrePoints = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                        deltaPerimetre = hauteurEau/deltaZ*distanceEntrePoints
                        deltaAbscisse = hauteurEau/deltaZ*(deltaCarreAbscisse**(1/2))
                        deltaSection = hauteurEau*deltaAbscisse/2
                        #On incremente le perimetre mouille et la section mouillee.
                        perimetreMouille = perimetreMouille + deltaPerimetre
                        sectionMouillee = sectionMouillee + deltaSection
                    listePointsNonMouilles.append(point)
                    dernierPointMouille = False
            #On connait maintenant le perimetre mouille et la section mouillee.
            #On ne connait pas encore la pente.
            #On va donc calculer la pente.
            pente = 0
            if numeroProfil == 0:
                #Dans ce cas, il n y a pas de profil a l amont. On ne considere que le profil aval.
                abscisseProfilSuivant = listeProfils[1][0]
                zProfilSuivant = listeProfils[1][1]
                abscisseProfil = profil[0]
                zProfil = profil[1]
                #On calcule la pente.
                pente = abs((zProfilSuivant-zProfil)/(abscisseProfilSuivant-abscisseProfil))
            elif numeroProfil < len(listeProfils) - 1:
                #Dans ce cas, il y a un profil a l amont et un profil a l aval.
                abscisseProfilPrecedent = listeProfils[numeroProfil - 1][0]
                zProfilPrecedent = listeProfils[numeroProfil - 1][1]
                abscisseProfilSuivant = listeProfils[numeroProfil + 1][0]
                zProfilSuivant = listeProfils[numeroProfil + 1][1]
                abscisseProfil = profil[0]
                zProfil = profil[1]
                #On calcule la pente amont.
                penteAmont = abs((zProfilPrecedent-zProfil)/(abscisseProfilPrecedent-abscisseProfil))
                #On calcule la pente aval.
                penteAval = abs((zProfilSuivant-zProfil)/(abscisseProfilSuivant-abscisseProfil))
                #On calcule la pente moyenne.
                pente = (penteAval + penteAmont)/2
            else:
                #Dans ce cas, il n y a pas de profil aval.
                abscisseProfilPrecedent = listeProfils[numeroProfil - 1][0]
                zProfilPrecedent = listeProfils[numeroProfil - 1][1]
                abscisseProfil = profil[0]
                zProfil = profil[1]
                #On calcule la pente.
                pente = abs((zProfilPrecedent-zProfil)/(abscisseProfilPrecedent-abscisseProfil))
            #On calcule la pente moyenne sur l'ensemble du cours d eau etudiee.
            penteMoyenne = abs((listeProfils[0][1] - listeProfils[len(listeProfils) - 1][1])/(listeProfils[0][0] - listeProfils[len(listeProfils) - 1][0]))
            #On calcule le debit maximal admissible au niveau du profil.
            if pente > penteMoyenne/10:
                debitMaximalProfil = coefficientStrickler*sectionMouillee*((sectionMouillee/perimetreMouille)**(2/3))*(pente**(1/2))
            else:
                debitMaximalProfil = coefficientStrickler*sectionMouillee*((sectionMouillee/perimetreMouille)**(2/3))*((penteMoyenne/10)**(1/2))
            if definitionDebitMaximal:
                if debitMaximal > debitMaximalProfil:
                    debitMaximal = debitMaximalProfil
            else:
                debitMaximal = debitMaximalProfil
                definitionDebitMaximal = True
            #On incremente du profil etudie la liste des profils avec pente.
            profilEtudie = [profil[3],pente,profil[1],profil[2]]
            listeProfilsAvecPente.append(profilEtudie)
            #On incremente d 1 le numero du profil
            numeroProfil = numeroProfil + 1
        #On renseigne l operateur sur l avancee des travaux.
        self.dlg.progressionCalculLigneEauInitiale.setValue(66)
        self.dlg.progressionCalculLigneEauInitiale.setFormat('Calcul en cours : debit maximal déterminé... (66%)')
        #On determine le debit pour lequel on va calculer les hauteurs d eau.
        debitPermanent = debitMaximal*tauxDebitMaximal
        #Pour chaque profil, on va determiner la hauteur d eau.
        #[profil[3],pente,profil[1],profil[2]] = [points, pente, minZ, minZberge]
        listeProfilsAvecZinitial = []
        for profil in listeProfilsAvecPente:
            #On extrait du tableau la pente au droit du profil.
            pente = profil[1]
            if pente == 0:
                pente = penteMoyenne/10
            #On calcule la valeur a chercher
            valeurAChercher = debitPermanent/(pente**(1/2)*coefficientStrickler)
            #On definit la premiere valeur de z pour laquelle on va calculer S x Rh**(2/3)
            zInitial = (profil[2] + profil[3])/2
            zSuperieur = profil[3]
            zInferieur = profil[2]
            parametresMouilles = self.calculSectionPerimetreMouilles(zInitial,profil[0])
            SRh = parametresMouilles[0]*parametresMouilles[1]**(2/3)
            #Au bout de 100 iterations, on arretera de chercher z.
            iteration = 0
            #On itere tant qu on n a pas suffisamment minimiser l erreur.
            while abs(SRh - valeurAChercher)/valeurAChercher > 0.05 and iteration < 101:
                if SRh > valeurAChercher:
                    zSuperieur = zInitial
                    zInitial = (zInitial + zInferieur)/2
                else:
                    zInferieur = zInitial
                    zInitial = (zInitial + zSuperieur)/2
                parametresMouilles = self.calculSectionPerimetreMouilles(zInitial,profil[0])
                SRh = parametresMouilles[0]*parametresMouilles[1]**(2/3)
                iteration = iteration + 1
            listeProfilsAvecZinitial.append([profil[0],round(zInitial,2)])
        #On construit maintenant les profils qui permettront de generer (par interpolation) la ligne d eau initiale.
        listeProfilsLigneEauInitiale = []
        for profil in listeProfilsAvecZinitial:
            #On boucle sur les points constituant le profil.
            pointPrecedentEnEau = False
            dernierPointEau = []
            dernierPointHorsEau = []
            listePointsLigneEau = []
            for point in profil[0]:
                #On simplifie la procedure. A decommentariser si on choisit la procedure complexe
                listePointsLigneEau.append([point[0],point[1],profil[1]])
                #On commentarise la procedure complexe.
                #if point[2] <= profil[1]:
                #    if pointPrecedentEnEau:
                #        listePointsLigneEau.append([point[0],point[1],profil[1]])
                #    else:
                #        if dernierPointHorsEau != []:
                #            xPointPrecedent = dernierPointHorsEau[0]
                #            yPointPrecedent = dernierPointHorsEau[1]
                #            zPointPrecedent = dernierPointHorsEau[2]
                #            xPointPresent = point[0]
                #            yPointPresent = point[1]
                #            zPointPresent = point[2]
                #            deltaPoint = ((xPointPrecedent - xPointPresent)**2 + (yPointPrecedent - yPointPresent)**2)**(1/2)
                #            deltaAltitude = abs(zPointPresent - zPointPrecedent)
                #            deltaZ = abs(zPointPresent - profil[1])
                #            deltaAbscisse = deltaPoint - deltaZ/deltaAltitude*deltaPoint
                #            xPoint = deltaAbscisse/deltaPoint*(xPointPresent - xPointPrecedent) + xPointPrecedent
                #            yPoint = deltaAbscisse/deltaPoint*(yPointPresent - yPointPrecedent) + yPointPrecedent 
                #            listePointsLigneEau.append([xPoint,yPoint,profil[1]])
                #            listePointsLigneEau.append([point[0],point[1],profil[1]])
                #        else:
                #            listePointsLigneEau.append([point[0],point[1],profil[1]])
                #    dernierPointEau = [point[0],point[1],point[2]]
                #    pointPrecedentEnEau = True
                #else:
                #    if not pointPrecedentEnEau:
                #        listePointsLigneEau.append([point[0],point[1],-99])
                #    else:
                #        if dernierPointEau != []:
                #            xPointPrecedent = dernierPointEau[0]
                #            yPointPrecedent = dernierPointEau[1]
                #            zPointPrecedent = dernierPointEau[2]
                #            xPointPresent = point[0]
                #            yPointPresent = point[1]
                #            zPointPresent = point[2]
                #            deltaPoint = ((xPointPrecedent - xPointPresent)**2 + (yPointPrecedent - yPointPresent)**2)**(1/2)
                #            deltaAltitude = abs(zPointPresent - zPointPrecedent)
                #            deltaZ = abs(zPointPresent - profil[1])
                #            deltaAbscisse = deltaPoint - deltaZ/deltaAltitude*deltaPoint
                #            xPoint = deltaAbscisse/deltaPoint*(xPointPresent - xPointPrecedent) + xPointPrecedent
                #            yPoint = deltaAbscisse/deltaPoint*(yPointPresent - yPointPrecedent) + yPointPrecedent 
                #            listePointsLigneEau.append([xPoint,yPoint,zInitial])
                #            listePointsLigneEau.append([point[0],point[1],-99])
                #        else:
                #            listePointsLigneEau.append([point[0],point[1],-99])
                #    dernierPointHorsEau = [point[0],point[1],point[2]]
                #    pointPrecedentEnEau = False
            listeProfilsLigneEauInitiale.append([listePointsLigneEau,profil[1]])
        #Creation de la couche vecteur dans lequel les profils donnant la ligne d eau seront stockes.
        uri = 'linestring?crs=epsg:2154&field=id:integer'
        coucheProfilsLigneEau = QgsVectorLayer(uri, 'profilsLigneEau', 'memory')
        #Le fichier vecteur produit comportera un champ : le champ donnant l altitude de la ligne d eau.
        listeChampsAAjouter = [QgsField("Z",QVariant.Double)]
        coucheProfilsLigneEau.dataProvider().addAttributes(listeChampsAAjouter)
        coucheProfilsLigneEau.updateFields()
        #On va ajouter les profils dans la coucheProfilsBathymetrique.
        id = 1
        for profilLigneEau in listeProfilsLigneEauInitiale:
            #Construction du fichier ou sont enregistres les profils donnant la ligne d eau.
            nouveauProfil = QgsFeature(coucheProfilsLigneEau.fields())
            listePointsLigneEau = []
            for pointLigneEau in profilLigneEau[0]:
                listePointsLigneEau.append(QgsPoint(pointLigneEau[0],pointLigneEau[1],round(pointLigneEau[2],2)))
            nouvelleGeometrie = QgsGeometry.fromPolyline(listePointsLigneEau)
            nouveauProfil.setGeometry(nouvelleGeometrie)
            nouveauProfil.setAttribute(0,id)
            nouveauProfil.setAttribute(1,profilLigneEau[1])
            coucheProfilsLigneEau.dataProvider().addFeatures([nouveauProfil])
            id = id + 1
        #On supprimer les fichiers a creer s'ils existent deja.
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationLigneEau.shp"):
            os.remove(pathDossierTravail+"ProfilsInterpolationLigneEau.shp")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationLigneEau.dbf"):
            os.remove(pathDossierTravail+"ProfilsInterpolationLigneEau.dbf")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationLigneEau.prj"):
            os.remove(pathDossierTravail+"ProfilsInterpolationLigneEau.prj")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationLigneEau.cpg"):
            os.remove(pathDossierTravail+"ProfilsInterpolationLigneEau.cpg")
        if  os.path.exists(pathDossierTravail+"ProfilsInterpolationLigneEau.qmd"):
            os.remove(pathDossierTravail+"ProfilsInterpolationLigneEau.qmd")
        #Creation du fichier shape final :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        save_options.includeZ = True
        save_options.overrideGeometryType = QgsWkbTypes.LineStringZ
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(coucheProfilsLigneEau,pathDossierTravail+"ProfilsInterpolationLigneEau.shp",transform_context,save_options)
        self.dlg.progressionCalculLigneEauInitiale.setValue(100)
        self.dlg.progressionCalculLigneEauInitiale.setFormat('Calcul terminé !')

    def calculSectionPerimetreMouilles(self,z,profil):
        #Soit un profil et une cote de l eau z.
        #On va calculer, pour cette configuration, la section mouillee et le perimetre mouille.
        listePointsMouilles = []
        listePointsNonMouilles = []
        dernierPointMouille = False
        #On initialise le perimetre mouille et la section mouillee.
        perimetreMouille = 0
        sectionMouillee = 0
        for point in profil:
            if point[2] < z or point[2] == z:
                if listePointsMouilles != []:
                    #Des points mouilles ont deja ete recenses.
                    #On regarde si le dernier point etudie etait un point mouille.
                    #Si c est le cas, on calcule la portion de perimetre mouille et de section mouillee supplementaire.
                    if dernierPointMouille:
                        pointMouillePrecedent = listePointsMouilles[len(listePointsMouilles)-1]
                        xPrecedent = pointMouillePrecedent[0]
                        yPrecedent = pointMouillePrecedent[1]
                        zPrecedent = pointMouillePrecedent[2]
                        xPresent = point[0]
                        yPresent = point[1]
                        zPresent = point[2]
                        zMoyen = (zPresent + zPrecedent)/2
                        hauteurEauMoyenne = z - zMoyen
                        deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                        deltaCarreZ = (zPresent - zPrecedent)**2
                        deltaPerimetre = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                        deltaSection = ((deltaCarreAbscisse)**(1/2))*hauteurEauMoyenne
                        #On incremente le perimetre mouille et la section mouillee.
                        perimetreMouille = perimetreMouille + deltaPerimetre
                        sectionMouillee = sectionMouillee + deltaSection
                    elif listePointsNonMouilles != []:
                        pointNonMouillePrecedent = listePointsNonMouilles[len(listePointsMouilles)-1]
                        xPrecedent = pointNonMouillePrecedent[0]
                        yPrecedent = pointNonMouillePrecedent[1]
                        zPrecedent = pointNonMouillePrecedent[2]
                        xPresent = point[0]
                        yPresent = point[1]
                        zPresent = point[2]
                        hauteurEau = z - zPresent
                        deltaZ = abs(zPrecedent - zPresent)
                        deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                        deltaCarreZ = (zPresent - zPrecedent)**2
                        distanceEntrePoints = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                        deltaPerimetre = hauteurEau/deltaZ*distanceEntrePoints
                        deltaAbscisse = hauteurEau/deltaZ*(deltaCarreAbscisse**(1/2))
                        deltaSection = hauteurEau*deltaAbscisse/2
                        #On incremente le perimetre mouille et la section mouillee.
                        perimetreMouille = perimetreMouille + deltaPerimetre
                        sectionMouillee = sectionMouillee + deltaSection
                else:
                    if listePointsNonMouilles != []:
                        pointNonMouillePrecedent = listePointsNonMouilles[len(listePointsMouilles)-1]
                        xPrecedent = pointNonMouillePrecedent[0]
                        yPrecedent = pointNonMouillePrecedent[1]
                        zPrecedent = pointNonMouillePrecedent[2]
                        xPresent = point[0]
                        yPresent = point[1]
                        zPresent = point[2]
                        hauteurEau = z - zPresent
                        deltaZ = abs(zPrecedent - zPresent)
                        deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                        deltaCarreZ = (zPresent - zPrecedent)**2
                        distanceEntrePoints = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                        deltaPerimetre = hauteurEau/deltaZ*distanceEntrePoints
                        deltaAbscisse = hauteurEau/deltaZ*(deltaCarreAbscisse**(1/2))
                        deltaSection = hauteurEau*deltaAbscisse/2
                        #On incremente le perimetre mouille et la section mouillee.
                        perimetreMouille = perimetreMouille + deltaPerimetre
                        sectionMouillee = sectionMouillee + deltaSection
                listePointsMouilles.append(point)
                dernierPointMouille = True
            else:
                if dernierPointMouille:
                    pointMouillePrecedent = listePointsMouilles[len(listePointsMouilles)-1]
                    xPrecedent = pointMouillePrecedent[0]
                    yPrecedent = pointMouillePrecedent[1]
                    zPrecedent = pointMouillePrecedent[2]
                    xPresent = point[0]
                    yPresent = point[1]
                    zPresent = point[2]
                    hauteurEau = z - zPrecedent
                    deltaZ = abs(zPrecedent - zPresent)
                    deltaCarreAbscisse = (xPresent - xPrecedent)**2 + (yPresent - yPrecedent)**2
                    deltaCarreZ = (zPresent - zPrecedent)**2
                    distanceEntrePoints = (deltaCarreAbscisse + deltaCarreZ)**(1/2)
                    deltaPerimetre = hauteurEau/deltaZ*distanceEntrePoints
                    deltaAbscisse = hauteurEau/deltaZ*(deltaCarreAbscisse**(1/2))
                    deltaSection = hauteurEau*deltaAbscisse/2
                    #On incremente le perimetre mouille et la section mouillee.
                    perimetreMouille = perimetreMouille + deltaPerimetre
                    sectionMouillee = sectionMouillee + deltaSection
                listePointsNonMouilles.append(point)
                dernierPointMouille = False
        return [sectionMouillee,perimetreMouille]
    
    def genererPolygoneBerges(self):
        self.dlg.infoPolygoneBergeConstruit.setText('Construction du polygone en cours...')
        #On recupere l adresse du fichier shape ou les berges sont definies.
        pathFichierBerges = self.dlg.fichierBergesPourPolygone.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des berges.
        recul = 1
        caractere = pathFichierBerges[len(pathFichierBerges)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierBerges[len(pathFichierBerges)-recul]
        pathDossierTravail = pathFichierBerges[:-recul+1]
        #Ouverture du fichier shape :
        coucheVecteurBerges = QgsVectorLayer(pathFichierBerges,"ogr")
        #On boucle sur les deux berges pour en recuperer les points qui les constituent.
        berges = coucheVecteurBerges.getFeatures()
        ListePointsPolygone = []
        for berge in berges:
            geometrieBerge = berge.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieBerge.wkbType())
            if geometrieBerge.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    x = geometrieBerge.asPolyline()
                else:
                    x = geometrieBerge.asMultiPolyline()
                    if berge[1] == "Gauche":
                        for point in x[0]:
                            ListePointsPolygone.append(point)
                    elif berge[1] == "Droite":
                        listePointsBonOrdre = x[0][::-1]
                        for point in listePointsBonOrdre:
                            ListePointsPolygone.append(point)
        #Creation de la couche vecteur dans lequel le polygone des berges sera stocke.
        uri = 'polygon?crs=epsg:2154&field=id:integer'
        couchePolygoneBerge = QgsVectorLayer(uri, 'PolygoneBerge', 'memory')
        #On cree l objet polygone.
        nouveauPolygone = QgsFeature(couchePolygoneBerge.fields())
        #On construit la geometrie du polygone.
        polygoneRiviere = QgsGeometry.fromMultiPolygonXY([[ListePointsPolygone]])
        #On affecte la geometrie a l objet polygone.
        nouveauPolygone.setGeometry(polygoneRiviere)
        #On ajoute le polygone a la couche.
        couchePolygoneBerge.dataProvider().addFeatures([nouveauPolygone])
        #On supprime les fichiers a creer s'ils existent deja.
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.shp"):
            os.remove(pathDossierTravail+"PolygoneBerges.shp")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.dbf"):
            os.remove(pathDossierTravail+"PolygoneBerges.dbf")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.prj"):
            os.remove(pathDossierTravail+"PolygoneBerges.prj")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.cpg"):
            os.remove(pathDossierTravail+"PolygoneBerges.cpg")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.qmd"):
            os.remove(pathDossierTravail+"PolygoneBerges.qmd")
        #Creation du fichier shape final :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(couchePolygoneBerge,pathDossierTravail+"PolygoneBerges.shp",transform_context,save_options)
        self.dlg.infoPolygoneBergeConstruit.setText('Construction du polygone achevée !')
    
    def genererBerges(self):
        #On initialise les donnees de la barre de progression.
        self.dlg.progressionConstructionBerges.setValue(0)
        self.dlg.progressionCalculProfilOuInterpoler.setTextVisible(True)
        self.dlg.progressionCalculLigneEauInitiale.setFormat('Construction des berges en cours... (0%)')
        #On recupere l adresse du fichier shape dans lequel l axe du cours d eau est decrit.
        pathFichierAxes = self.dlg.fichierAxeCoursDEauGenerationBerges.filePath()
        #On recupere l adresse du MNT.
        pathFichierMNT = self.dlg.fichierMNTGenerationBerges.filePath()
        #On recupere le MNT (sous forme de raster).
        fileInfo = QFileInfo(pathFichierMNT)
        baseName = fileInfo.baseName()
        coucheRaster = QgsRasterLayer(pathFichierMNT,baseName)
        #On recupere la discretisation de l axe du cours d eau.
        discretisationAxe = float(self.dlg.discretisationAxe.text())
        #On recupere la discretisation du profil en travers.
        discretisationProfilTravers = float(self.dlg.discretisationProfilTravers.text())
        #On recupere la dimension de la maille du MNT.
        largeurMaximaleRiviere = float(self.dlg.largeurMaximaleRiviere.text())
        #On recupere le critere de detection des berges.
        critereDetectionBerges = float(self.dlg.critereDetectionBerge.text())
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des profils bathymetriques.
        recul = 1
        caractere = pathFichierAxes[len(pathFichierAxes)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierAxes[len(pathFichierAxes)-recul]
        pathDossierTravail = pathFichierAxes[:-recul+1]
        #On cree le repertoire ou stocker les fichiers points.
        if os.path.exists(pathDossierTravail+'/ProfilsIntermediairesPoints'):
            for fichier in os.listdir(pathDossierTravail+'/ProfilsIntermediairesPoints'):
                os.remove(pathDossierTravail+'/ProfilsIntermediairesPoints/'+fichier)
        else:
            os.makedirs(pathDossierTravail+'/ProfilsIntermediairesPoints')
        
        #On va boucler sur les axes pour construire les berges. Normalement, il n y a qu un axe.
        coucheAxesCoursDEau = QgsVectorLayer(pathFichierAxes,"ogr")
        axes = coucheAxesCoursDEau.getFeatures()
        for axe in axes:
            geometrieAxe = axe.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieAxe.wkbType())
            if geometrieAxe.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoAxe = geometrieAxe.asPolyline()
                else:
                    geoAxe = geometrieAxe.asMultiPolyline()
            #On va parcourir l axe pour determiner les coordonnees des points et leurs abscisses curvilignes.
            descriptifAxeCoursDEau = []
            distanceLongAxe = 0
            for numPointLigne in range(len(geoAxe[0])-1):
                pointA = geoAxe[0][numPointLigne]
                pointB = geoAxe[0][numPointLigne+1]
                x_pointA = pointA.x()
                y_pointA = pointA.y()
                x_pointB = pointB.x()
                y_pointB = pointB.y()
                positionProfil = 0
                listeProfilsAEnlever = []
                descriptifAxeCoursDEau.append([x_pointA,y_pointA,distanceLongAxe])
                distanceLongAxe = distanceLongAxe + ((x_pointA-x_pointB)**2+(y_pointA-y_pointB)**2)**(1/2)
            descriptifAxeCoursDEau.append([x_pointB,y_pointB,distanceLongAxe])
            #On initialise les listes bergeGauche et bergeDroite.
            #Dans ces listes, il sera stockee les coordonnees des points constituant les berges droite et gauche.
            bergeGauche = []
            bergeDroite = []
            #On initialise les donnees internes (donnees necessaires pour que l algorithme fonctionne).
            positionAxe = 0
            numProfil = 1
            #On initialise les donnees allant servir pour montrer la progression du calcul.
            incrementProgression = 1
            progression = 1
            #On construit les profils en travers. Ces profils en travers sont discretises.
            #Au niveau de chaque point, on extrait du MNT l altitude du point.
            while positionAxe < distanceLongAxe:
                segmentAxe = 0
                while positionAxe > descriptifAxeCoursDEau[segmentAxe][2]:
                    segmentAxe = segmentAxe+1
                #On construit le premier profil.
                if segmentAxe == 0:
                    #On determine le point d intersection du profil avec l axe.
                    #Ensuite, on determine le coefficient directeur du profil.
                    x_pointOrigine = descriptifAxeCoursDEau[segmentAxe][0]
                    y_pointOrigine = descriptifAxeCoursDEau[segmentAxe][1]
                    x_pointExtremite = descriptifAxeCoursDEau[segmentAxe+1][0]
                    y_pointExtremite = descriptifAxeCoursDEau[segmentAxe+1][1]
                    x_pointAxe = x_pointOrigine
                    y_pointAxe = y_pointOrigine
                    x_coefDir = y_pointOrigine - y_pointExtremite
                    y_coefDir = x_pointExtremite - x_pointOrigine
                #On construit les profils suivants.
                else:
                    #On determine le point d intersection du profil avec l axe.
                    #Ensuite, on determine le coefficient directeur du profil.
                    x_pointOrigine = descriptifAxeCoursDEau[segmentAxe-1][0]
                    y_pointOrigine = descriptifAxeCoursDEau[segmentAxe-1][1]
                    x_pointExtremite = descriptifAxeCoursDEau[segmentAxe][0]
                    y_pointExtremite = descriptifAxeCoursDEau[segmentAxe][1]
                    x_coefDir = y_pointOrigine - y_pointExtremite
                    y_coefDir = x_pointExtremite - x_pointOrigine
                    #On determine les coordonnees du point de l'axe a partir duquel rayonneront les branches du profil.
                    #Attention : le coefficient directeur est celui du profil, pas celui du segment (d ou l'inversion des
                    #coordonnees)
                    x_pointAxe = x_pointOrigine + y_coefDir/((x_coefDir**2+y_coefDir**2)**(1/2))*(positionAxe - descriptifAxeCoursDEau[segmentAxe-1][2])
                    y_pointAxe = y_pointOrigine - x_coefDir/((x_coefDir**2+y_coefDir**2)**(1/2))*(positionAxe - descriptifAxeCoursDEau[segmentAxe-1][2])
                #On construit les points constituant le profil en travers.
                #Le profil en travers est perpendiculaire a l'axe du cours d'eau.
                #Les points situes a droite de l axe sont numerotes avec des nombres negatifs.
                #Ceux situes a gauche de l axe sont numerotes avec des nombres positifs.
                #Dans tous les cas, les numeros vont croissants quand on s eloigne de l axe.
                listePointsProfil = []
                positionPoint = -1/2*largeurMaximaleRiviere - 1
                numPosition = -1
                raisonSuite = -1
                while positionPoint < 1/2*largeurMaximaleRiviere + 1:
                    if positionPoint < discretisationProfilTravers and positionPoint > 0:
                        listePointsProfil.append([x_pointAxe,y_pointAxe,0])
                        numPosition = 1
                        raisonSuite = 1
                    if positionPoint == 0:
                        listePointsProfil.append([x_pointAxe,y_pointAxe,0])
                        numPosition = 1
                        raisonSuite = 1
                    else:
                        x_pointProfil = x_pointAxe + positionPoint*x_coefDir/((x_coefDir**2+y_coefDir**2)**(1/2))
                        y_pointProfil = y_pointAxe + positionPoint*y_coefDir/((x_coefDir**2+y_coefDir**2)**(1/2))
                        listePointsProfil.append([x_pointProfil,y_pointProfil,numPosition])
                        numPosition = numPosition + raisonSuite
                    positionPoint = positionPoint + discretisationProfilTravers
                #On cree un fichier shape dans lequel sont stockes les points ou les donnees raster seront extraites.
                #La donnee extraite sera l altitude. L analyse des altitudes permettra de determiner les positions des berges.
                #Creation de la couche vecteur dans lequel les points seront stockes.
                
                # uri = 'point?crs=epsg:2154&field=id:integer'
                # couchePointsCoursDEau = QgsVectorLayer(uri, 'PointsCoursDEau', 'memory')
                # #On cree les objets point.
                # for point in listePointsProfil:
                #     nouveauPoint = QgsFeature(couchePointsCoursDEau.fields())
                #     #On construit la geometrie du point.
                #     geometriePoint = QgsGeometry.fromPointXY(QgsPointXY(point[0],point[1]))
                #     #On affecte la geometrie a l objet point.
                #     nouveauPoint.setGeometry(geometriePoint)
                #     nouveauPoint.setAttribute(0,point[2])
                #     #On ajoute le point a la couche.
                #     couchePointsCoursDEau.dataProvider().addFeatures([nouveauPoint])
                
                #On supprime les fichiers a creer s'ils existent deja.
                #if  os.path.exists(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp"):
                #    os.remove(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp")
                #if  os.path.exists(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp"):
                #    os.remove(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp")
                #if  os.path.exists(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp"):
                #    os.remove(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp")
                #if  os.path.exists(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp"):
                #    os.remove(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp")
                #if  os.path.exists(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp"):
                #    os.remove(pathDossierTravail+"PointsProfil_"+str(numProfil)+".shp")
                #Creation du fichier shape final :
                
                
                # save_options = QgsVectorFileWriter.SaveVectorOptions()
                # save_options.driverName = "ESRI Shapefile"
                # save_options.fileEncoding = "UTF-8"
                # transform_context = QgsProject.instance().transformContext()
                # writer = QgsVectorFileWriter.writeAsVectorFormatV3(couchePointsCoursDEau,pathDossierTravail+'/ProfilsIntermediairesPoints/PointsProfil_'+str(numProfil)+'.shp',transform_context,save_options)
                # #del writer
                # #On utilise l algorithme de QGis pour associer a chaque point une altitude.
                # alg_params = {
                #     'BAND': 1,
                #     'INPUT': pathDossierTravail+'/ProfilsIntermediairesPoints/PointsProfil_'+str(numProfil)+'.shp',
                #     'NODATA': -99,
                #     'OFFSET': 0,
                #     'RASTER': pathFichierMNT,
                #     'SCALE': 1,
                #     'OUTPUT': pathDossierTravail+'/ProfilsIntermediairesPoints/PointsProfilAvecZ_'+str(numProfil)+'.shp'
                # }
                # processing.run('native:setzfromraster', alg_params)
                
                #Pour chaque point du profil, on recupere l altitude.
                #On calcule ce z a partir du MNT.
                minPoint = 0
                dictZPoints = {}
                for point in listePointsProfil:
                    x_point = point[0]
                    y_point = point[1]
                    donneesPoint = coucheRaster.dataProvider().identify(QgsPointXY(x_point,y_point), QgsRaster.IdentifyFormatValue)
                    zPoint = donneesPoint.results()[1]
                    dictZPoints.update({point[2]:zPoint})
                    if point[2] < minPoint:
                        minPoint = point[2]
                
                # #On recupere les points du profil.
                # couchePointsAvecZ = QgsVectorLayer(pathDossierTravail+'/ProfilsIntermediairesPoints/PointsProfilAvecZ_'+str(numProfil)+'.shp',"ogr")
                # points = couchePointsAvecZ.getFeatures()
                # dictZPoints = {}
                # minPoint = 0
                # #Pour chaque point du profil, on recupere l altitude.
                # for point in points:
                #     geometriePoint = point.geometry()
                #     zPoint = round(float(geometriePoint.asWkt().split(' ')[3][:-1]),2)
                #     dictZPoints.update({point[0]:zPoint})
                #     if point[0] < minPoint:
                #         minPoint = point[0]

                #On definit la cote de reference. La cote de reference est la cote du point d intersection de l axe avec le profil.
                zReference = dictZPoints[0]
                #On recherche le numero du point a ajouter a la berge droite.
                positionPoint = minPoint
                while dictZPoints[positionPoint] < zReference + critereDetectionBerges:
                    positionPoint = positionPoint+1
                    if positionPoint not in dictZPoints:
                        break
                if positionPoint > minPoint:
                    pointBergeDroite = positionPoint-1
                else:
                    pointBergeDroite = minPoint
                #On recherche le numero du point a ajouter a la berge gauche.
                positionPoint = 1
                while dictZPoints[positionPoint] < zReference + critereDetectionBerges:
                    positionPoint = positionPoint+1
                    if positionPoint not in dictZPoints:
                        break
                pointBergeGauche = positionPoint-1
                #On boucle sur les points du profil pour extraire les coordonnees des points a ajouter aux berges droite et gauche.
                for point in listePointsProfil:
                    if point[2] == pointBergeGauche:
                        bergeGauche.append([point[0],point[1]])
                    if point[2] == pointBergeDroite:
                        bergeDroite.append([point[0],point[1]])
                
                # points = couchePointsAvecZ.getFeatures()
                # for point in points:
                #     if point[0] == pointBergeGauche:
                #         geometriePoint = point.geometry()
                #         geomSingleType = QgsWkbTypes.isSingleType(geometriePoint.wkbType())
                #         if geometriePoint.type() == QgsWkbTypes.PointGeometry:
                #             if geomSingleType:
                #                 geoPoint = geometriePoint.asPoint()
                #             else:
                #                 geoPoint = geometriePoint.asMultiPoint()
                #         x_point = geoPoint.x()
                #         y_point = geoPoint.y()
                #         bergeGauche.append([x_point,y_point])
                #     if point[0] == pointBergeDroite:
                #         geometriePoint = point.geometry()
                #         geomSingleType = QgsWkbTypes.isSingleType(geometriePoint.wkbType())
                #         if geometriePoint.type() == QgsWkbTypes.PointGeometry:
                #             if geomSingleType:
                #                 geoPoint = geometriePoint.asPoint()
                #             else:
                #                 geoPoint = geometriePoint.asMultiPoint()
                #         x_point = geoPoint.x()
                #         y_point = geoPoint.y()
                #         bergeDroite.append([x_point,y_point])

                #On rend compte a l utilisateur de la progression du calcul.
                if positionAxe/distanceLongAxe > progression/100:
                    self.dlg.progressionConstructionBerges.setValue(progression)
                    self.dlg.progressionCalculProfilOuInterpoler.setTextVisible(True)
                    self.dlg.progressionCalculLigneEauInitiale.setFormat('Construction des berges en cours... ('+str(progression)+'%)')
                    progression = int(positionAxe/distanceLongAxe*100)+incrementProgression
                positionAxe = positionAxe + discretisationAxe
                numProfil = numProfil+1
            #On va eliminer des berges droite et gauche les points qui "reviennent en arriere".
            #Pour cela, on va determiner si des profils successifs s intersectent entre les berges.
            #Si c est le cas, il faut eliminer le point.
            #On va ainsi construire les berges consolidees. Celles-ci sont initialisees ci-dessous.
            bergeGaucheConsolidee = []
            bergeDroiteConsolidee = []
            profilGauchePrecedent = []
            profilDroitPrecedent = []
            #On boucle sur les profils.
            for numProfil in range(len(bergeGauche)):
                pointRiveGauche = bergeGauche[numProfil]
                pointRiveDroite = bergeDroite[numProfil]
                x_coefDirProfil = pointRiveDroite[0] - pointRiveGauche[0]
                y_coefDirProfil = pointRiveDroite[1] - pointRiveGauche[1]
                #Il s'agit du premier profil rencontre. Evidemment, il ne peut pas en intersecter d autres.
                #On initialise les donnees de l algorithme
                if profilGauchePrecedent == []:
                    profilGauchePrecedent = [pointRiveGauche,pointRiveDroite]
                    bergeGaucheConsolidee.append(pointRiveGauche)
                    profilDroitPrecedent = [pointRiveGauche,pointRiveDroite]
                    bergeDroiteConsolidee.append(pointRiveDroite)
                #On étudie les profils suivants.
                else:
                    #On determine le coefficient directeur du profil.
                    x_coefDirProfilPrec = profilGauchePrecedent[1][0] - profilGauchePrecedent[0][0]
                    y_coefDirProfilPrec = profilGauchePrecedent[1][1] - profilGauchePrecedent[0][1]
                    pointIntersection = self.xy_pointIntersection(pointRiveGauche[0],pointRiveGauche[1],x_coefDirProfil,y_coefDirProfil,profilGauchePrecedent[0][0],profilGauchePrecedent[0][1],x_coefDirProfilPrec,y_coefDirProfilPrec)
                    if pointIntersection != ['inf','inf']:
                        if (pointIntersection[0] - pointRiveGauche[0])*(pointIntersection[0] - pointRiveDroite[0]) > 0 or (pointIntersection[1] - pointRiveGauche[1])*(pointIntersection[1] - pointRiveDroite[1]) > 0:
                            #Le profil n intersecte pas les profils precedents (du moins, le point d intersection n est pas entre les berges).
                            #On retient les deux points du profil.
                            bergeGaucheConsolidee.append(pointRiveGauche)
                            profilGauchePrecedent = [pointRiveGauche,pointRiveDroite]
                            bergeDroiteConsolidee.append(pointRiveDroite)
                            profilDroitPrecedent = [pointRiveGauche,pointRiveDroite]
                        elif -x_coefDirProfilPrec*y_coefDirProfil + y_coefDirProfilPrec*x_coefDirProfil < 0:
                            #Il y a intersection du cote gauche de l axe. On ne retient pas le point en rive gauche.
                            bergeDroiteConsolidee.append(pointRiveDroite)
                            profilGauchePrecedent = [pointRiveGauche,pointRiveDroite]
                        elif -x_coefDirProfilPrec*y_coefDirProfil + y_coefDirProfilPrec*x_coefDirProfil > 0:
                            #Il y a intersection du cote droit de l axe. On ne retient pas le point en rive droite.
                            bergeGaucheConsolidee.append(pointRiveGauche)
                            profilDroitPrecedent = [pointRiveGauche,pointRiveDroite]
                    else:
                        #Le profil n intersecte pas les profils precedents. Le profil est parallele au profil precedent.
                        #On retient les deux points du profil
                        bergeGaucheConsolidee.append(pointRiveGauche)
                        profilGauchePrecedent = [pointRiveGauche,pointRiveDroite]
                        bergeDroiteConsolidee.append(pointRiveDroite)
                        profilDroitPrecedent = [pointRiveGauche,pointRiveDroite]
            #On va construire le fichier shape dans lequel les berges seront definies.
            uri = 'linestring?crs=epsg:2154'
            coucheBerges = QgsVectorLayer(uri, 'Berges', 'memory')
            listeChampsAAjouter = [QgsField('id',QVariant.Int),QgsField('Berge',QVariant.String)]
            coucheBerges.dataProvider().addAttributes(listeChampsAAjouter)
            coucheBerges.updateFields()
            #On construit la ligne de la berge gauche.
            ligneBergeGauche = QgsFeature(coucheBerges.fields())
            listePointsBergeGauche = []
            for point in bergeGaucheConsolidee:
                listePointsBergeGauche.append(QgsPointXY(point[0],point[1]))
            geometrieBergeGauche = QgsGeometry.fromMultiPolylineXY([listePointsBergeGauche])
            ligneBergeGauche.setGeometry(geometrieBergeGauche)
            ligneBergeGauche.setAttribute(0,0)
            ligneBergeGauche.setAttribute(1,"Gauche")
            #On construit la ligne de la berge droite.
            ligneBergeDroite = QgsFeature(coucheBerges.fields())
            listePointsBergeDroite = []
            for point in bergeDroiteConsolidee:
                listePointsBergeDroite.append(QgsPointXY(point[0],point[1]))
            geometrieBergeDroite = QgsGeometry.fromMultiPolylineXY([listePointsBergeDroite])
            ligneBergeDroite.setGeometry(geometrieBergeDroite)
            ligneBergeDroite.setAttribute(0,1)
            ligneBergeDroite.setAttribute(1,"Droite")
            #On ajoute les berges dans la couche vecteur.
            coucheBerges.dataProvider().addFeatures([ligneBergeGauche])
            coucheBerges.dataProvider().addFeatures([ligneBergeDroite])
            #Creation du fichier shape final :
            save_options = QgsVectorFileWriter.SaveVectorOptions()
            save_options.driverName = "ESRI Shapefile"
            save_options.fileEncoding = "UTF-8"
            transform_context = QgsProject.instance().transformContext()
            writer = QgsVectorFileWriter.writeAsVectorFormatV3(coucheBerges,pathDossierTravail+"BergesBathysseur.shp",transform_context,save_options)
            self.dlg.progressionConstructionBerges.setValue(100)
            self.dlg.progressionCalculProfilOuInterpoler.setTextVisible(True)
            self.dlg.progressionCalculLigneEauInitiale.setFormat('Les berges ont été générées !')
    
    def genererProfilsAvecBathymetrie(self):
        
        #On recupere l adresse du fichier shape genere a partir du fichier dwg fourni par le geometre.
        pathFichierGeometre = self.dlg.fichierGeometre.filePath()
        #On recupere l adresse du fichier dans lequel l axe du cours d eau est decrit.
        pathFichierAxe = self.dlg.fichierAxePourProfilsBathy.filePath()
        #On recupere l adresse du fichier dans lequel les berges sont decrites.
        pathFichierBerges = self.dlg.fichierBergesPourProfilsBathy.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des profils produits par le geometre.
        recul = 1
        caractere = pathFichierGeometre[len(pathFichierGeometre)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierGeometre[len(pathFichierGeometre)-recul]
        pathDossierTravail = pathFichierGeometre[:-recul+1]
        #On recupere la geometrie de l axe du cours d eau.
        coucheAxe = QgsVectorLayer(pathFichierAxe,"ogr")
        axes = coucheAxe.getFeatures()
        # (Normalement, il n y a qu un axe.)
        for axe in axes:
            geometrieAxe = axe.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieAxe.wkbType())
            if geometrieAxe.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoAxe = geometrieAxe.asPolyline()
                else:
                    geoAxe = geometrieAxe.asMultiPolyline()
        #On va parcourir l axe du cours d eau pour determiner les coordonnees des points et leurs abscisses curvilignes.
        descriptifAxeCoursDEau = []
        distanceLongAxe = 0
        for numPointLigne in range(len(geoAxe[0])-1):
            pointA = geoAxe[0][numPointLigne]
            pointB = geoAxe[0][numPointLigne+1]
            x_pointA = pointA.x()
            y_pointA = pointA.y()
            x_pointB = pointB.x()
            y_pointB = pointB.y()
            positionProfil = 0
            listeProfilsAEnlever = []
            descriptifAxeCoursDEau.append([x_pointA,y_pointA,distanceLongAxe])
            distanceLongAxe = distanceLongAxe + ((x_pointA-x_pointB)**2+(y_pointA-y_pointB)**2)**(1/2)
        #On recupere la geometrie des berges.
        tableauBerge = {}
        coucheBerges = QgsVectorLayer(pathFichierBerges,"ogr")
        berges = coucheBerges.getFeatures()
        for berge in berges:
            geometrieBerge = berge.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieBerge.wkbType())
            if geometrieBerge.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoBerge = geometrieBerge.asPolyline()
                else:
                    geoBerge = geometrieBerge.asMultiPolyline()
            #On va parcourir la berge pour determiner les coordonnees des points.
            descriptifBerge = []
            for numPointBerge in range(len(geoBerge[0])):
                point = geoBerge[0][numPointBerge]
                x_point = point.x()
                y_point = point.y()
                descriptifBerge.append([x_point,y_point])
            if berge[1] == 'Gauche':
                tableauBerge.update({'Gauche':descriptifBerge})
            elif berge[1] == 'Droite':
                tableauBerge.update({'Droite':descriptifBerge})
        #On recupere les geometries des profils.
        descriptifProfilsGeometre = []
        descriptifMultiProfilsGeometre = []
        coucheProfilsGeometre = QgsVectorLayer(pathFichierGeometre,"ogr")
        profilsGeometre = coucheProfilsGeometre.getFeatures()
        for profilGeometre in profilsGeometre:
            descriptifProfilGeometre = []
            descriptifMultiProfilGeometre = []
            geometrieProfilGeometre = profilGeometre.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieProfilGeometre.wkbType())
            if geometrieProfilGeometre.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoProfilSingleTypeGeometre = geometrieProfilGeometre.asPolyline()
                    geoProfilGeometre = [geoProfilSingleTypeGeometre]
                else:
                    geoProfilGeometre = geometrieProfilGeometre.asMultiPolyline()
            #On va parcourir le profil pour recenser les differents points qui le composent.
            #Il est egalement extrait les altitudes de ces points.
            numMultiLigne = 0
            for geo in geoProfilGeometre:
                descriptifProfilGeometrePourMultiProfil = []
                for numPointLigne in range(len(geo)):
                #for numPointLigne in range(len(geoProfilGeometre[0])):
                    point = geo[numPointLigne]
                    x_point = point.x()
                    y_point = point.y()
                    z_point = round(float(geometrieProfilGeometre.asWkt()[19:-2].split('),(')[numMultiLigne].split(', ')[numPointLigne].split(' ')[2]),2)
                    descriptifProfilGeometre.append([x_point,y_point,z_point])
                    descriptifProfilGeometrePourMultiProfil.append([x_point,y_point,z_point])
                descriptifMultiProfilGeometre.append(descriptifProfilGeometrePourMultiProfil)
                numMultiLigne = numMultiLigne + 1
            descriptifProfilsGeometre.append(descriptifProfilGeometre)
            descriptifMultiProfilsGeometre.append(descriptifMultiProfilGeometre)
        #On recherche les points d'intersection des profils issus des releves du geometre avec l axe du cours d eau.
        #On calcule ensuite l abscisse des points d intersection des profils avec l axe du cours d eau.
        abscissesProfilsGeometre = []
        descriptifProfilsGeometreOrdonne = []
        descriptifMultiProfilsGeometreOrdonne = []
        numsProfsIntersectes = []
        for numPointAxe in range(len(descriptifAxeCoursDEau)-1):
            x_pointDepart = descriptifAxeCoursDEau[numPointAxe][0]
            y_pointDepart = descriptifAxeCoursDEau[numPointAxe][1]
            x_pointArrivee = descriptifAxeCoursDEau[numPointAxe+1][0]
            y_pointArrivee = descriptifAxeCoursDEau[numPointAxe+1][1]
            x_coefDirAxe = x_pointArrivee - x_pointDepart
            y_coefDirAxe = y_pointArrivee - y_pointDepart
            # profilsGeometre = coucheProfilsGeometre.getFeatures()
            for numeroMultiProfil in range(len(descriptifMultiProfilsGeometre)):
                for numeroProfil in range(len(descriptifMultiProfilsGeometre[numeroMultiProfil])):
                    descriptifProfil = descriptifMultiProfilsGeometre[numeroMultiProfil][numeroProfil]
                    for numPointProfil in range(len(descriptifProfil)-1):
                        x_pointA = descriptifProfil[numPointProfil][0]
                        y_pointA = descriptifProfil[numPointProfil][1]
                        x_pointB = descriptifProfil[numPointProfil+1][0]
                        y_pointB = descriptifProfil[numPointProfil+1][1]
                        x_coefDirSegment = x_pointB - x_pointA
                        y_coefDirSegment = y_pointB - y_pointA
                        intersectionAxeProfil = self.xy_pointIntersection(x_pointDepart,y_pointDepart,x_coefDirAxe,y_coefDirAxe,x_pointA,y_pointA,x_coefDirSegment,y_coefDirSegment)
                        if intersectionAxeProfil != ['inf','inf']:
                            if (x_pointA - intersectionAxeProfil[0])*(x_pointB - intersectionAxeProfil[0]) <= 0.001 and (y_pointA - intersectionAxeProfil[1])*(y_pointB - intersectionAxeProfil[1]) <= 0.001:
                                if (x_pointDepart - intersectionAxeProfil[0])*(x_pointArrivee - intersectionAxeProfil[0]) <= 0.001 and (y_pointDepart - intersectionAxeProfil[1])*(y_pointArrivee - intersectionAxeProfil[1]) <= 0.001:
                                    distanceAAjouter = ((descriptifAxeCoursDEau[numPointAxe][0] - intersectionAxeProfil[0])**2 + (descriptifAxeCoursDEau[numPointAxe][1] - intersectionAxeProfil[1])**2)**(1/2)
                                    abscissePositionProfil = descriptifAxeCoursDEau[numPointAxe][2] + distanceAAjouter
                                    abscissesProfilsGeometre.append(abscissePositionProfil)
                                    descriptifProfilsGeometreOrdonne.append(descriptifProfilsGeometre[numeroMultiProfil])
                                    descriptifMultiProfilsGeometreOrdonne.append(descriptifMultiProfilsGeometre[numeroMultiProfil])
        #On recherche les points d intersection des profils avec les berges.
        pointsIntersectionBergeGauche = self.intersectionsBergeProfilsGeometre(tableauBerge['Gauche'],descriptifMultiProfilsGeometreOrdonne)
        pointsIntersectionBergeDroite = self.intersectionsBergeProfilsGeometre(tableauBerge['Droite'],descriptifMultiProfilsGeometreOrdonne)
        #On construit les profils finaux. Au depart, les profils du geometre sont potentiellement des polylignes. Autrement dit, les profils dum
        #geometre peuvent etre composes de plusieurs segments. Ces profils vont etre simplifies. Les profils construits seront de simples segments de droite.
        #On profite egalement de cette boucle pour associer les points bathymetriques a un profil. Le tableau construit permettra de generer le fichier des
        #points bathymetriques.
        profilsGeometreSimplifies = []
        pointsBathyAvecZ = []
        for numProfilGeometre in range(len(abscissesProfilsGeometre)):
            #On construit le profil simplifie.
            numProfil = round(abscissesProfilsGeometre[numProfilGeometre])
            pointGauche = pointsIntersectionBergeGauche[numProfilGeometre]
            pointDroite = pointsIntersectionBergeDroite[numProfilGeometre]
            x_coefDir = pointDroite[0] - pointGauche[0]
            y_coefDir = pointDroite[1] - pointGauche[1]
            normeCoefDir = (x_coefDir**2 + y_coefDir**2)**(1/2)
            xG = pointGauche[0] - x_coefDir/normeCoefDir
            yG = pointGauche[1] - y_coefDir/normeCoefDir
            xD = pointDroite[0] + x_coefDir/normeCoefDir
            yD = pointDroite[1] + y_coefDir/normeCoefDir
            profilsGeometreSimplifies.append([QgsPointXY(xG,yG),QgsPointXY(xD,yD),numProfil])
            #On implemente le tableau des points bathymetriques. On affecte un numero de profil aux points qu on ajoute.
            descriptifProfil = descriptifProfilsGeometreOrdonne[numProfilGeometre]
            for point in descriptifProfil:
                pointProfil = [QgsPointXY(point[0],point[1]),point[2],numProfil]
                pointsBathyAvecZ.append(pointProfil)
        #Creation de la couche vecteur dans laquelle seront stockes les profils du geometre.
        uri1 = 'linestring?crs=epsg:2154&field=id:integer'
        coucheProfilsGeometre = QgsVectorLayer(uri1, 'profilsGeometre', 'memory')
        #Creation de la couche vecteur dans laquelle seront stockes les points bathymetriques.
        uri2 = 'point?crs=epsg:2154&field=id:integer'
        couchepointsBathyAssocieProfilsGeometre = QgsVectorLayer(uri2, 'pointsBathyAssocieProfilsGeometre', 'memory')
        listeChampsAAjouter = [QgsField("Z",QVariant.Double)]
        couchepointsBathyAssocieProfilsGeometre.dataProvider().addAttributes(listeChampsAAjouter)
        couchepointsBathyAssocieProfilsGeometre.updateFields()
        #On va ajouter les profils du geometre dans la coucheProfilsGeometre.
        for profil in profilsGeometreSimplifies:
            nouveauProfil = QgsFeature(coucheProfilsGeometre.fields())
            nouvelleGeometrie = QgsGeometry.fromMultiPolylineXY([[profil[0],profil[1]]])
            nouveauProfil.setGeometry(nouvelleGeometrie)
            nouveauProfil.setAttribute(0,profil[2])
            coucheProfilsGeometre.dataProvider().addFeatures([nouveauProfil])
        #On va ajouter les profils du geometre dans la coucheProfilsGeometre.
        for point in pointsBathyAvecZ:
            nouveauPoint = QgsFeature(couchepointsBathyAssocieProfilsGeometre.fields())
            nouvelleGeometrie = QgsGeometry.fromPointXY(point[0])
            nouveauPoint.setGeometry(nouvelleGeometrie)
            nouveauPoint.setAttribute(0,point[2])
            nouveauPoint.setAttribute(1,point[1])
            couchepointsBathyAssocieProfilsGeometre.dataProvider().addFeatures([nouveauPoint])
        if  os.path.exists(pathDossierTravail+"ProfilsGeometre.shp"):
            os.remove(pathDossierTravail+"ProfilsGeometre.shp")
        if  os.path.exists(pathDossierTravail+"ProfilsGeometre.dbf"):
            os.remove(pathDossierTravail+"ProfilsGeometre.dbf")
        if  os.path.exists(pathDossierTravail+"ProfilsGeometre.prj"):
            os.remove(pathDossierTravail+"ProfilsGeometre.prj")
        if  os.path.exists(pathDossierTravail+"ProfilsGeometre.cpg"):
            os.remove(pathDossierTravail+"ProfilsGeometre.cpg")
        if  os.path.exists(pathDossierTravail+"ProfilsGeometre.qmd"):
            os.remove(pathDossierTravail+"ProfilsGeometre.qmd")
        if  os.path.exists(pathDossierTravail+"PointsGeometre.shp"):
            os.remove(pathDossierTravail+"PointsGeometre.shp")
        if  os.path.exists(pathDossierTravail+"PointsGeometre.dbf"):
            os.remove(pathDossierTravail+"PointsGeometre.dbf")
        if  os.path.exists(pathDossierTravail+"PointsGeometre.prj"):
            os.remove(pathDossierTravail+"PointsGeometre.prj")
        if  os.path.exists(pathDossierTravail+"PointsGeometre.cpg"):
            os.remove(pathDossierTravail+"PointsGeometre.cpg")
        if  os.path.exists(pathDossierTravail+"PointsGeometre.qmd"):
            os.remove(pathDossierTravail+"PointsGeometre.qmd")
        #Creation des fichiers shape finaux :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(coucheProfilsGeometre,pathDossierTravail+"ProfilsGeometre.shp",transform_context,save_options)
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(couchepointsBathyAssocieProfilsGeometre,pathDossierTravail+"PointsGeometre.shp",transform_context,save_options)
        #Generation du polygone des berges :
        # -> Ouverture du fichier shape :
        coucheVecteurBerges = QgsVectorLayer(pathFichierBerges,"ogr")
        # -> On boucle sur les deux berges pour en recuperer les points qui les constituent.
        berges = coucheVecteurBerges.getFeatures()
        ListePointsPolygone = []
        for berge in berges:
            geometrieBerge = berge.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieBerge.wkbType())
            if geometrieBerge.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    x = geometrieBerge.asPolyline()
                else:
                    x = geometrieBerge.asMultiPolyline()
                    if berge[1] == "Gauche":
                        for point in x[0]:
                            ListePointsPolygone.append(point)
                    elif berge[1] == "Droite":
                        listePointsBonOrdre = x[0][::-1]
                        for point in listePointsBonOrdre:
                            ListePointsPolygone.append(point)
        # -> Creation de la couche vecteur dans lequel le polygone des berges sera stocke.
        uri = 'polygon?crs=epsg:2154&field=id:integer'
        couchePolygoneBerge = QgsVectorLayer(uri, 'PolygoneBerge', 'memory')
        # -> On cree l objet polygone.
        nouveauPolygone = QgsFeature(couchePolygoneBerge.fields())
        # -> On construit la geometrie du polygone.
        polygoneRiviere = QgsGeometry.fromMultiPolygonXY([[ListePointsPolygone]])
        # -> On affecte la geometrie a l objet polygone.
        nouveauPolygone.setGeometry(polygoneRiviere)
        # -> On ajoute le polygone a la couche.
        couchePolygoneBerge.dataProvider().addFeatures([nouveauPolygone])
        # -> On supprime les fichiers a creer s'ils existent deja.
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.shp"):
            os.remove(pathDossierTravail+"PolygoneBerges.shp")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.dbf"):
            os.remove(pathDossierTravail+"PolygoneBerges.dbf")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.prj"):
            os.remove(pathDossierTravail+"PolygoneBerges.prj")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.cpg"):
            os.remove(pathDossierTravail+"PolygoneBerges.cpg")
        if  os.path.exists(pathDossierTravail+"PolygoneBerges.qmd"):
            os.remove(pathDossierTravail+"PolygoneBerges.qmd")
        # -> Creation du fichier shape final :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(couchePolygoneBerge,pathDossierTravail+"PolygoneBerges.shp",transform_context,save_options)
        #Selection des points (issus des profils du geometre) situes entre les berges du cours d eau :
        parametres = {'INPUT':pathDossierTravail+'PointsGeometre.shp',
        'PREDICATE':[0],
        'INTERSECT':pathDossierTravail+"PolygoneBerges.shp",
        'OUTPUT':pathDossierTravail+'PointsGeometreRiviere.shp'}
        processing.run("native:extractbylocation", parametres)
        
        #Dialogue avec l utilisateur.
        #self.dlg.progressionCalculProfilOuInterpoler.setValue(100)
        #self.dlg.progressionCalculProfilOuInterpoler.setFormat('Calcul terminé !')

    def intersectionsBergeProfilsGeometre(self,descriptifBerge,descriptifMultiProfils):
        pointsIntersection = []
        for numeroMultiProfil in range(len(descriptifMultiProfils)):
            pointsIntersectionSegmentBerge = []
            for numeroProfil in range(len(descriptifMultiProfils[numeroMultiProfil])):
                descriptifProfil = descriptifMultiProfils[numeroMultiProfil][numeroProfil]
                for numPointBerge in range(len(descriptifBerge)-1):
                    x_pointDepart = descriptifBerge[numPointBerge][0]
                    y_pointDepart = descriptifBerge[numPointBerge][1]
                    x_pointArrivee = descriptifBerge[numPointBerge+1][0]
                    y_pointArrivee = descriptifBerge[numPointBerge+1][1]
                    x_coefDirAxe = x_pointArrivee - x_pointDepart
                    y_coefDirAxe = y_pointArrivee - y_pointDepart
                    for numPointProfil in range(len(descriptifProfil)-1):
                        x_pointA = descriptifProfil[numPointProfil][0]
                        y_pointA = descriptifProfil[numPointProfil][1]
                        x_pointB = descriptifProfil[numPointProfil+1][0]
                        y_pointB = descriptifProfil[numPointProfil+1][1]
                        x_coefDirSegment = x_pointB - x_pointA
                        y_coefDirSegment = y_pointB - y_pointA
                        intersectionBergeProfil = self.xy_pointIntersection(x_pointDepart,y_pointDepart,x_coefDirAxe,y_coefDirAxe,x_pointA,y_pointA,x_coefDirSegment,y_coefDirSegment)
                        if intersectionBergeProfil != ['inf','inf']:
                            if (x_pointA - intersectionBergeProfil[0])*(x_pointB - intersectionBergeProfil[0]) <= 0.0001 and (y_pointA - intersectionBergeProfil[1])*(y_pointB - intersectionBergeProfil[1]) <= 0.0001:
                                if (x_pointDepart - intersectionBergeProfil[0])*(x_pointArrivee - intersectionBergeProfil[0]) <= 0.0001 and (y_pointDepart - intersectionBergeProfil[1])*(y_pointArrivee - intersectionBergeProfil[1]) <= 0.0001:
                                    pointsIntersectionSegmentBerge.append(intersectionBergeProfil)
            pointAConserver = []
            for pointIntersection in pointsIntersectionSegmentBerge:
                sommeDistance = 0
                for numeroProfil in range(len(descriptifMultiProfils[numeroMultiProfil])):
                    for numPointProfil in range(len(descriptifProfil)):
                        x_point = descriptifProfil[numPointProfil][0]
                        y_point = descriptifProfil[numPointProfil][1]
                        distance = (pointIntersection[0] - x_point)**2 + (pointIntersection[1] - y_point)**2
                        sommeDistance = sommeDistance + distance
                if pointAConserver == []:
                    pointAConserver = [pointIntersection,sommeDistance]
                else:
                    if sommeDistance < pointAConserver[1]:
                        pointAConserver = [pointIntersection,sommeDistance]
            pointsIntersection.append(pointAConserver[0])
        return pointsIntersection
    
    def affectationPointsProfils(self):
        #On recupere l adresse du fichier shape dans lequel sont stockes les points bathymetriques.
        pathFichierPointsGeometre = self.dlg.fichierPointsGeometre.filePath()
        #On recupere l adresse du fichier dans lequel les profils bathymetriques sont decrits.
        pathFichierProfilsBathy = self.dlg.fichierProfilsSansPoints.filePath()
        #Definition du repertoire de travail : le repertoire de travail est le dossier ou
        #est range le fichier des profils produits par le geometre.
        recul = 1
        caractere =pathFichierProfilsBathy[len(pathFichierProfilsBathy)-recul]
        while caractere != '/' and caractere != '\\':
            recul = recul+1
            caractere = pathFichierProfilsBathy[len(pathFichierProfilsBathy)-recul]
        pathDossierTravail = pathFichierProfilsBathy[:-recul+1]
        #On recupere la distance maximale qui peut exister entre les profils et les points bathymetriques.
        distanceMaximale = float(self.dlg.distanceMaximalePointsProfils.text())
        #On recupere les points bathymetriques.
        #Ceux-ci ne sont pas, pour l instant, affectes a un profil.
        couchePointsGeometre = QgsVectorLayer(pathFichierPointsGeometre,"ogr")
        pointsGeometre = couchePointsGeometre.getFeatures()
        #On recupere la couche des profils bathymetriques.
        coucheProfilsBathy = QgsVectorLayer(pathFichierProfilsBathy,"ogr")
        #On recupere les profils bathymetriques.
        profilsBathy = coucheProfilsBathy.getFeatures()
        #On recupere les caracteristiques geometriques des profils bathymetriques.
        descriptionProfils = []
        for profil in profilsBathy:
            geometrieProfil = profil.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometrieProfil.wkbType())
            if geometrieProfil.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    geoSingleTypeProfil = geometrieProfil.asPolyline()
                    geoProfil = [geoSingleTypeProfil]
                else:
                    geoProfil = geometrieProfil.asMultiPolyline()
            #On ne prend en compte que le premier segment de la multiligne.
            #On considere que l utilisateur n a pas constitue des lignes comptant plusieurs segments.
            x_pointOrigine = geoProfil[0][0].x()
            x_pointExtremite = geoProfil[0][1].x()
            y_pointOrigine = geoProfil[0][0].y()
            y_pointExtremite = geoProfil[0][1].y()
            x_coefDir = x_pointExtremite - x_pointOrigine
            y_coefDir = y_pointExtremite - y_pointOrigine
            descriptionProfils.append([x_pointOrigine,y_pointOrigine,x_coefDir,y_coefDir,x_pointExtremite,y_pointExtremite,profil[0]])
        #On initialise la liste des points bathymetriques a conserver.
        listePointsBathyAConserver = []
        #On boucle sur les points bathymetriques pour determiner a quels profils il faut les affecter.
        for point in pointsGeometre:
            #On recupere la geometrie du point.
            geometriePoint = point.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geometriePoint.wkbType())
            if geometriePoint.type() == QgsWkbTypes.PointGeometry:
                if geomSingleType:
                    geoPoint = geometriePoint.asPoint()
                else:
                    geoPoint = geometriePoint.asMultiPoint()
            #On recupere les coordonnees x et y du point.
            x_point = geoPoint.x()
            y_point = geoPoint.y()
            #On initialise la liste des profils possibles :
            listeProfilsPossibles = []
            #On recupere les profils bathymetriques auxquels on pourrait associer le point bathymetrique.
            for profil in descriptionProfils:
                pointIntersection = self.xy_pointIntersection(x_point,y_point,-profil[3],profil[2],profil[0],profil[1],profil[2],profil[3])
                if pointIntersection != ['inf','inf']:
                    if (profil[0] - pointIntersection[0])*(profil[4] - pointIntersection[0]) <= 0.0001 and (profil[1] - pointIntersection[1])*(profil[5] - pointIntersection[1]) <= 0.0001:
                        distanceAuProfil = (x_point - pointIntersection[0])**2 + (y_point - pointIntersection[1])**2
                        if distanceAuProfil < distanceMaximale:
                            listeProfilsPossibles.append([profil[6],distanceAuProfil])
            if listeProfilsPossibles != []:
                if len(listeProfilsPossibles) == 1:
                    listePointsBathyAConserver.append([x_point,y_point,point[0],listeProfilsPossibles[0][0]])
                else:
                    #Il y a plusieurs profils possibles.
                    #On identifie le profil dont le point etudie est le plus proche.
                    #On affectera le point etudie a ce profil.
                    distanceMin = listeProfilsPossibles[0][1]
                    numeroProfil = listeProfilsPossibles[0][0]
                    for profilPossible in listeProfilsPossibles:
                        if profilPossible[1] < distanceMin:
                            distanceMin = profilPossible[1]
                            numeroProfil = profilPossible[0]
                    listePointsBathyAConserver.apend([x_point,y_point,point[0],numeroProfil])
        #On cree le fichier shape dans lequel on stockera les points bathymetriques.
        uri = 'point?crs=epsg:2154&field=id:integer'
        couchePointsBathyAssociesProfils = QgsVectorLayer(uri, 'pointsBathyAssocieProfils', 'memory')
        listeChampsAAjouter = [QgsField("Z",QVariant.Double)]
        couchePointsBathyAssociesProfils.dataProvider().addAttributes(listeChampsAAjouter)
        couchePointsBathyAssociesProfils.updateFields()
        #On boucle sur les points retenus pour les ajouter au fichier shape.
        for point in listePointsBathyAConserver:
            nouveauPoint = QgsFeature(couchePointsBathyAssociesProfils.fields())
            nouvelleGeometrie = QgsGeometry.fromPointXY(QgsPointXY(point[0],point[1]))
            nouveauPoint.setGeometry(nouvelleGeometrie)
            nouveauPoint.setAttribute(0,point[3])
            nouveauPoint.setAttribute(1,point[2])
            couchePointsBathyAssociesProfils.dataProvider().addFeatures([nouveauPoint])
        #On supprime les fichiers existants.
        if  os.path.exists(pathDossierTravail+"PointsGeometreAssociesProfils.shp"):
            os.remove(pathDossierTravail+"PointsGeometreAssociesProfils.shp")
        if  os.path.exists(pathDossierTravail+"PointsGeometreAssociesProfils.dbf"):
            os.remove(pathDossierTravail+"PointsGeometreAssociesProfils.dbf")
        if  os.path.exists(pathDossierTravail+"PointsGeometreAssociesProfils.prj"):
            os.remove(pathDossierTravail+"PointsGeometreAssociesProfils.prj")
        if  os.path.exists(pathDossierTravail+"PointsGeometreAssociesProfils.cpg"):
            os.remove(pathDossierTravail+"PointsGeometreAssociesProfils.cpg")
        if  os.path.exists(pathDossierTravail+"PointsGeometreAssociesProfils.qmd"):
            os.remove(pathDossierTravail+"PointsGeometreAssociesProfils.qmd")
        # -> Creation du fichier shape final :
        save_options = QgsVectorFileWriter.SaveVectorOptions()
        save_options.driverName = "ESRI Shapefile"
        save_options.fileEncoding = "UTF-8"
        transform_context = QgsProject.instance().transformContext()
        writer = QgsVectorFileWriter.writeAsVectorFormatV3(couchePointsBathyAssociesProfils,pathDossierTravail+"PointsGeometreAssociesProfils.shp",transform_context,save_options)
        #Selection des points (issus des profils du geometre) situes entre les berges du cours d eau :
        parametres = {'INPUT':pathDossierTravail+'PointsGeometreAssociesProfils.shp',
        'PREDICATE':[0],
        'INTERSECT':pathDossierTravail+"PolygoneBerges.shp",
        'OUTPUT':pathDossierTravail+'PointsGeometreAssociesProfilsRiviere.shp'}
        processing.run("native:extractbylocation", parametres)

    def aideCalculDiscretisation(self):
        self.messageAide = BathysseurDialogAideDiscretisation()
        self.messageAide.show()
        #messageAide = QMessageBox()
        #messageAide.setIcon(QMessageBox.Information)
        #messageAide.setText('Calcul de la discrétisation recommandée')
        #messageAide.setWindowTitle('Le bouton "Calculer (facultatif)" se base sur la longueur moyenne des.')
        #messageAide.setStandardButtons(QMessageBox.Ok)
        #messageAide.show()
        #msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        #messageAide.buttonClicked.connect(msgButtonClick)
    
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = BathysseurDialog()
            self.dlg.boutonGenererProfilsIntermediaires.clicked.connect(self.genererProfilsInterpolation)
            self.dlg.boutonDeterminerZBerges.clicked.connect(self.determinerZBerges)
            self.dlg.interpolationBathymetrie.clicked.connect(self.interpolationBathymetrieSurProfil)
            self.dlg.constructionBathymetrieVirtuelle.clicked.connect(self.bathymetrieElliptique)
            self.dlg.genererLigneEauInitiale.clicked.connect(self.genererLigneEau)
            self.dlg.constructionPolygoneBerge.clicked.connect(self.genererPolygoneBerges)
            self.dlg.boutonGenererLesBerges.clicked.connect(self.genererBerges)
            self.dlg.constructionProfilsAvecBathymetrie.clicked.connect(self.genererProfilsAvecBathymetrie)
            self.dlg.boutonCalculDiscretisation.clicked.connect(self.calculDiscretisationProfil)
            self.dlg.constructionRasterBathymetrie.clicked.connect(self.constructionRasterBathymetrie)
            self.dlg.boutonAideDiscretisation.clicked.connect(self.aideCalculDiscretisation)
            self.dlg.boutonAffectationPointsProfils.clicked.connect(self.affectationPointsProfils)
            self.dlg.progressionCalculProfilOuInterpoler.setValue(0)
            self.dlg.progressionCalculBathymetrieConnue.setValue(0)
            self.dlg.progressionCalculBathymetrieVirtuelle.setValue(0)
            self.dlg.progressionCalculLigneEauInitiale.setValue(0)
            self.dlg.progressionConstructionBerges.setValue(0)

        # show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
